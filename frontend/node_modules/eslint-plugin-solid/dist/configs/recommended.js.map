{"version":3,"sources":["../../package.json","../../src/rules/components-return-once.ts","../../src/compat.ts","../../src/utils.ts","../../src/rules/event-handlers.ts","../../src/rules/imports.ts","../../src/rules/jsx-no-duplicate-props.ts","../../src/rules/jsx-no-script-url.ts","../../src/rules/jsx-no-undef.ts","../../src/rules/jsx-uses-vars.ts","../../src/rules/no-destructure.ts","../../src/rules/no-innerhtml.ts","../../src/rules/no-proxy-apis.ts","../../src/rules/no-react-deps.ts","../../src/rules/no-react-specific-props.ts","../../src/rules/no-unknown-namespaces.ts","../../src/rules/prefer-classlist.ts","../../src/rules/prefer-for.ts","../../src/rules/prefer-show.ts","../../src/rules/reactivity.ts","../../src/rules/self-closing-comp.ts","../../src/rules/style-prop.ts","../../src/rules/no-array-handlers.ts","../../src/plugin.ts","../../src/configs/recommended.ts"],"sourcesContent":["{\n  \"name\": \"eslint-plugin-solid\",\n  \"version\": \"0.14.5\",\n  \"description\": \"Solid-specific linting rules for ESLint.\",\n  \"keywords\": [\n    \"eslint\",\n    \"eslintplugin\",\n    \"solid\",\n    \"solidjs\",\n    \"reactivity\"\n  ],\n  \"repository\": \"https://github.com/solidjs-community/eslint-plugin-solid\",\n  \"license\": \"MIT\",\n  \"author\": \"Josh Wilson <joshwilsonvu@gmail.com>\",\n  \"exports\": {\n    \".\": {\n      \"types\": {\n        \"import\": \"./dist/index.d.mts\",\n        \"require\": \"./dist/index.d.ts\"\n      },\n      \"import\": \"./dist/index.mjs\",\n      \"require\": \"./dist/index.js\"\n    },\n    \"./configs/recommended\": {\n      \"types\": {\n        \"import\": \"./dist/configs/recommended.d.mts\",\n        \"require\": \"./dist/configs/recommended.d.ts\"\n      },\n      \"import\": \"./dist/configs/recommended.mjs\",\n      \"require\": \"./dist/configs/recommended.js\"\n    },\n    \"./configs/typescript\": {\n      \"types\": {\n        \"import\": \"./dist/configs/typescript.d.mts\",\n        \"require\": \"./dist/configs/typescript.d.ts\"\n      },\n      \"import\": \"./dist/configs/typescript.mjs\",\n      \"require\": \"./dist/configs/typescript.js\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"files\": [\n    \"src\",\n    \"dist\",\n    \"README.md\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"test\": \"vitest --run\",\n    \"test:all\": \"PARSER=all vitest --run\",\n    \"test:babel\": \"PARSER=babel vitest --run\",\n    \"test:ts\": \"PARSER=ts vitest --run\",\n    \"test:v6\": \"PARSER=v6 vitest --run\",\n    \"test:v7\": \"PARSER=v7 vitest --run\",\n    \"test:watch\": \"vitest\",\n    \"turbo:build\": \"tsup\",\n    \"turbo:docs\": \"PARSER=none tsx scripts/docs.ts\",\n    \"turbo:test\": \"vitest --run\"\n  },\n  \"dependencies\": {\n    \"@typescript-eslint/utils\": \"^7.13.1 || ^8.0.0\",\n    \"estraverse\": \"^5.3.0\",\n    \"is-html\": \"^2.0.0\",\n    \"kebab-case\": \"^1.0.2\",\n    \"known-css-properties\": \"^0.30.0\",\n    \"style-to-object\": \"^1.0.6\"\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.24.4\",\n    \"@babel/eslint-parser\": \"^7.24.7\",\n    \"@microsoft/api-extractor\": \"^7.47.6\",\n    \"@types/eslint\": \"^8.56.10\",\n    \"@types/eslint-v6\": \"npm:@types/eslint@6\",\n    \"@types/eslint-v7\": \"npm:@types/eslint@7\",\n    \"@types/eslint-v8\": \"npm:@types/eslint@8\",\n    \"@types/eslint__js\": \"^8.42.3\",\n    \"@types/estraverse\": \"^5.1.7\",\n    \"@types/is-html\": \"^2.0.2\",\n    \"@typescript-eslint/eslint-plugin\": \"^8.0.0\",\n    \"@typescript-eslint/parser\": \"^8.0.0\",\n    \"eslint\": \"^9.5.0\",\n    \"eslint-v6\": \"npm:eslint@6\",\n    \"eslint-v7\": \"npm:eslint@7\",\n    \"eslint-v8\": \"npm:eslint@8\",\n    \"markdown-magic\": \"^3.3.0\",\n    \"prettier\": \"^2.8.8\",\n    \"tsup\": \"^8.2.4\",\n    \"tsx\": \"^4.17.0\",\n    \"vitest\": \"^1.5.2\"\n  },\n  \"peerDependencies\": {\n    \"eslint\": \"^6.0.0 || ^7.0.0 || ^8.0.0 || ^9.0.0\",\n    \"typescript\": \">=4.8.4\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  }\n}\n","/**\n * FIXME: remove this comments and import when below issue is fixed.\n * This import is necessary for type generation due to a bug in the TypeScript compiler.\n * See: https://github.com/microsoft/TypeScript/issues/42873\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { TSESLint } from \"@typescript-eslint/utils\";\n\nimport { TSESTree as T, ESLintUtils } from \"@typescript-eslint/utils\";\nimport { getFunctionName, type FunctionNode } from \"../utils\";\nimport { getSourceCode } from \"../compat\";\n\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\n\nconst isNothing = (node?: T.Node): boolean => {\n  if (!node) {\n    return true;\n  }\n  switch (node.type) {\n    case \"Literal\":\n      return ([null, undefined, false, \"\"] as Array<unknown>).includes(node.value);\n    case \"JSXFragment\":\n      return !node.children || node.children.every(isNothing);\n    default:\n      return false;\n  }\n};\n\nconst getLineLength = (loc: T.SourceLocation) => loc.end.line - loc.start.line + 1;\n\nexport default createRule({\n  meta: {\n    type: \"problem\",\n    docs: {\n      description:\n        \"Disallow early returns in components. Solid components only run once, and so conditionals should be inside JSX.\",\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/components-return-once.md\",\n    },\n    fixable: \"code\",\n    schema: [],\n    messages: {\n      noEarlyReturn:\n        \"Solid components run once, so an early return breaks reactivity. Move the condition inside a JSX element, such as a fragment or <Show />.\",\n      noConditionalReturn:\n        \"Solid components run once, so a conditional return breaks reactivity. Move the condition inside a JSX element, such as a fragment or <Show />.\",\n    },\n  },\n  defaultOptions: [],\n  create(context) {\n    const functionStack: Array<{\n      /** switched to true by :exit if the current function is detected to be a component */\n      isComponent: boolean;\n      lastReturn: T.ReturnStatement | undefined;\n      earlyReturns: Array<T.ReturnStatement>;\n    }> = [];\n    const putIntoJSX = (node: T.Node): string => {\n      const text = getSourceCode(context).getText(node);\n      return node.type === \"JSXElement\" || node.type === \"JSXFragment\" ? text : `{${text}}`;\n    };\n    const currentFunction = () => functionStack[functionStack.length - 1];\n    const onFunctionEnter = (node: FunctionNode) => {\n      let lastReturn: T.ReturnStatement | undefined;\n      if (node.body.type === \"BlockStatement\") {\n        // find last statement, ignoring function/class/variable declarations (hoisting)\n        const last = node.body.body.findLast((node) => !node.type.endsWith(\"Declaration\"));\n        // if it's a return, store it\n        if (last && last.type === \"ReturnStatement\") {\n          lastReturn = last;\n        }\n      }\n      functionStack.push({ isComponent: false, lastReturn, earlyReturns: [] });\n    };\n\n    const onFunctionExit = (node: FunctionNode) => {\n      if (\n        // \"render props\" aren't components\n        getFunctionName(node)?.match(/^[a-z]/) ||\n        node.parent?.type === \"JSXExpressionContainer\" ||\n        // ignore createMemo(() => conditional JSX), report HOC(() => conditional JSX)\n        (node.parent?.type === \"CallExpression\" &&\n          node.parent.arguments.some((n) => n === node) &&\n          !(node.parent.callee as T.Identifier).name?.match(/^[A-Z]/))\n      ) {\n        currentFunction().isComponent = false;\n      }\n      if (currentFunction().isComponent) {\n        // Warn on each early return\n        currentFunction().earlyReturns.forEach((earlyReturn) => {\n          context.report({\n            node: earlyReturn,\n            messageId: \"noEarlyReturn\",\n          });\n        });\n\n        const argument = currentFunction().lastReturn?.argument;\n        if (argument?.type === \"ConditionalExpression\") {\n          const sourceCode = getSourceCode(context);\n          context.report({\n            node: argument.parent!,\n            messageId: \"noConditionalReturn\",\n            fix: (fixer) => {\n              const { test, consequent, alternate } = argument;\n              const conditions = [{ test, consequent }];\n              let fallback = alternate;\n\n              while (fallback.type === \"ConditionalExpression\") {\n                conditions.push({ test: fallback.test, consequent: fallback.consequent });\n                fallback = fallback.alternate;\n              }\n\n              if (conditions.length >= 2) {\n                // we have a nested ternary, use <Switch><Match /></Switch>\n                const fallbackStr = !isNothing(fallback)\n                  ? ` fallback={${sourceCode.getText(fallback)}}`\n                  : \"\";\n                return fixer.replaceText(\n                  argument,\n                  `<Switch${fallbackStr}>\\n${conditions\n                    .map(\n                      ({ test, consequent }) =>\n                        `<Match when={${sourceCode.getText(test)}}>${putIntoJSX(\n                          consequent\n                        )}</Match>`\n                    )\n                    .join(\"\\n\")}\\n</Switch>`\n                );\n              }\n              if (isNothing(consequent)) {\n                // we have a single ternary and the consequent is nothing. Negate the condition and use a <Show>.\n                return fixer.replaceText(\n                  argument,\n                  `<Show when={!(${sourceCode.getText(test)})}>${putIntoJSX(alternate)}</Show>`\n                );\n              }\n              if (\n                isNothing(fallback) ||\n                getLineLength(consequent.loc) >= getLineLength(alternate.loc) * 1.5\n              ) {\n                // we have a standard ternary, and the alternate is a bit shorter in LOC than the consequent, which\n                // should be enough to tell that it's logically a fallback instead of an equal branch.\n                const fallbackStr = !isNothing(fallback)\n                  ? ` fallback={${sourceCode.getText(fallback)}}`\n                  : \"\";\n                return fixer.replaceText(\n                  argument,\n                  `<Show when={${sourceCode.getText(test)}}${fallbackStr}>${putIntoJSX(\n                    consequent\n                  )}</Show>`\n                );\n              }\n\n              // we have a standard ternary, but no signal from the user as to which branch is the \"fallback\" and\n              // which is the children. Move the whole conditional inside a JSX fragment.\n              return fixer.replaceText(argument, `<>${putIntoJSX(argument)}</>`);\n            },\n          });\n        } else if (argument?.type === \"LogicalExpression\") {\n          if (argument.operator === \"&&\") {\n            const sourceCode = getSourceCode(context);\n            // we have a `return condition && expression`--put that in a <Show />\n            context.report({\n              node: argument,\n              messageId: \"noConditionalReturn\",\n              fix: (fixer) => {\n                const { left: test, right: consequent } = argument;\n                return fixer.replaceText(\n                  argument,\n                  `<Show when={${sourceCode.getText(test)}}>${putIntoJSX(consequent)}</Show>`\n                );\n              },\n            });\n          } else {\n            // we have some other kind of conditional, warn\n            context.report({\n              node: argument,\n              messageId: \"noConditionalReturn\",\n            });\n          }\n        }\n      }\n\n      // Pop on exit\n      functionStack.pop();\n    };\n    return {\n      FunctionDeclaration: onFunctionEnter,\n      FunctionExpression: onFunctionEnter,\n      ArrowFunctionExpression: onFunctionEnter,\n      \"FunctionDeclaration:exit\": onFunctionExit,\n      \"FunctionExpression:exit\": onFunctionExit,\n      \"ArrowFunctionExpression:exit\": onFunctionExit,\n      JSXElement() {\n        if (functionStack.length) {\n          currentFunction().isComponent = true;\n        }\n      },\n      JSXFragment() {\n        if (functionStack.length) {\n          currentFunction().isComponent = true;\n        }\n      },\n      ReturnStatement(node) {\n        if (functionStack.length && node !== currentFunction().lastReturn) {\n          currentFunction().earlyReturns.push(node);\n        }\n      },\n    };\n  },\n});\n","import { type TSESLint, type TSESTree, ASTUtils } from \"@typescript-eslint/utils\";\n\nexport type CompatContext =\n  | {\n      sourceCode: Readonly<TSESLint.SourceCode>;\n      getSourceCode: undefined;\n      getScope: undefined;\n      markVariableAsUsed: undefined;\n    }\n  | {\n      sourceCode?: Readonly<TSESLint.SourceCode>;\n      getSourceCode: () => Readonly<TSESLint.SourceCode>;\n      getScope: () => TSESLint.Scope.Scope;\n      markVariableAsUsed: (name: string) => void;\n    };\n\nexport function getSourceCode(context: CompatContext) {\n  if (typeof context.getSourceCode === \"function\") {\n    return context.getSourceCode();\n  }\n  return context.sourceCode;\n}\n\nexport function getScope(context: CompatContext, node: TSESTree.Node): TSESLint.Scope.Scope {\n  const sourceCode = getSourceCode(context);\n\n  if (typeof sourceCode.getScope === \"function\") {\n    return sourceCode.getScope(node); // >= v8, I think\n  }\n  if (typeof context.getScope === \"function\") {\n    return context.getScope();\n  }\n  return context.sourceCode.getScope(node);\n}\n\nexport function findVariable(\n  context: CompatContext,\n  node: TSESTree.Identifier\n): TSESLint.Scope.Variable | null {\n  return ASTUtils.findVariable(getScope(context, node), node);\n}\n\nexport function markVariableAsUsed(\n  context: CompatContext,\n  name: string,\n  node: TSESTree.Node\n): void {\n  if (typeof context.markVariableAsUsed === \"function\") {\n    context.markVariableAsUsed(name);\n  } else {\n    getSourceCode(context).markVariableAsUsed(name, node);\n  }\n}\n","import { TSESTree as T, TSESLint } from \"@typescript-eslint/utils\";\nimport { CompatContext, findVariable } from \"./compat\";\n\nconst domElementRegex = /^[a-z]/;\nexport const isDOMElementName = (name: string): boolean => domElementRegex.test(name);\n\nconst propsRegex = /[pP]rops/;\nexport const isPropsByName = (name: string): boolean => propsRegex.test(name);\n\nexport const formatList = (strings: Array<string>): string => {\n  if (strings.length === 0) {\n    return \"\";\n  } else if (strings.length === 1) {\n    return `'${strings[0]}'`;\n  } else if (strings.length === 2) {\n    return `'${strings[0]}' and '${strings[1]}'`;\n  } else {\n    const last = strings.length - 1;\n    return `${strings\n      .slice(0, last)\n      .map((s) => `'${s}'`)\n      .join(\", \")}, and '${strings[last]}'`;\n  }\n};\n\nexport const find = (node: T.Node, predicate: (node: T.Node) => boolean): T.Node | null => {\n  let n: T.Node | undefined = node;\n  while (n) {\n    const result = predicate(n);\n    if (result) {\n      return n;\n    }\n    n = n.parent;\n  }\n  return null;\n};\nexport function findParent<Guard extends T.Node>(\n  node: T.Node,\n  predicate: (node: T.Node) => node is Guard\n): Guard | null;\nexport function findParent(node: T.Node, predicate: (node: T.Node) => boolean): T.Node | null;\nexport function findParent(node: T.Node, predicate: (node: T.Node) => boolean): T.Node | null {\n  return node.parent ? find(node.parent, predicate) : null;\n}\n\n// Try to resolve a variable to its definition\nexport function trace(node: T.Node, context: CompatContext): T.Node {\n  if (node.type === \"Identifier\") {\n    const variable = findVariable(context, node);\n    if (!variable) return node;\n\n    const def = variable.defs[0];\n\n    // def is `undefined` for Identifier `undefined`\n    switch (def?.type) {\n      case \"FunctionName\":\n      case \"ClassName\":\n      case \"ImportBinding\":\n        return def.node;\n      case \"Variable\":\n        if (\n          ((def.node.parent as T.VariableDeclaration).kind === \"const\" ||\n            variable.references.every((ref) => ref.init || ref.isReadOnly())) &&\n          def.node.id.type === \"Identifier\" &&\n          def.node.init\n        ) {\n          return trace(def.node.init, context);\n        }\n    }\n  }\n  return node;\n}\n\n/** Get the relevant node when wrapped by a node that doesn't change the behavior */\nexport function ignoreTransparentWrappers(node: T.Node, up = false): T.Node {\n  if (\n    node.type === \"TSAsExpression\" ||\n    node.type === \"TSNonNullExpression\" ||\n    node.type === \"TSSatisfiesExpression\"\n  ) {\n    const next = up ? node.parent : node.expression;\n    if (next) {\n      return ignoreTransparentWrappers(next, up);\n    }\n  }\n  return node;\n}\n\nexport type FunctionNode = T.FunctionExpression | T.ArrowFunctionExpression | T.FunctionDeclaration;\nconst FUNCTION_TYPES = [\"FunctionExpression\", \"ArrowFunctionExpression\", \"FunctionDeclaration\"];\nexport const isFunctionNode = (node: T.Node | null | undefined): node is FunctionNode =>\n  !!node && FUNCTION_TYPES.includes(node.type);\n\nexport type ProgramOrFunctionNode = FunctionNode | T.Program;\nconst PROGRAM_OR_FUNCTION_TYPES = [\"Program\"].concat(FUNCTION_TYPES);\nexport const isProgramOrFunctionNode = (\n  node: T.Node | null | undefined\n): node is ProgramOrFunctionNode => !!node && PROGRAM_OR_FUNCTION_TYPES.includes(node.type);\n\nexport const isJSXElementOrFragment = (\n  node: T.Node | null | undefined\n): node is T.JSXElement | T.JSXFragment =>\n  node?.type === \"JSXElement\" || node?.type === \"JSXFragment\";\n\nexport const getFunctionName = (node: FunctionNode): string | null => {\n  if (\n    (node.type === \"FunctionDeclaration\" || node.type === \"FunctionExpression\") &&\n    node.id != null\n  ) {\n    return node.id.name;\n  }\n  if (node.parent?.type === \"VariableDeclarator\" && node.parent.id.type === \"Identifier\") {\n    return node.parent.id.name;\n  }\n  return null;\n};\n\nexport function findInScope(\n  node: T.Node,\n  scope: ProgramOrFunctionNode,\n  predicate: (node: T.Node) => boolean\n): T.Node | null {\n  const found = find(node, (node) => node === scope || predicate(node));\n  return found === scope && !predicate(node) ? null : found;\n}\n\n// The next two functions were adapted from \"eslint-plugin-import\" under the MIT license.\n\n// Checks whether `node` has a comment (that ends) on the previous line or on\n// the same line as `node` (starts).\nexport const getCommentBefore = (\n  node: T.Node,\n  sourceCode: TSESLint.SourceCode\n): T.Comment | undefined =>\n  sourceCode\n    .getCommentsBefore(node)\n    .find((comment) => comment.loc!.end.line >= node.loc!.start.line - 1);\n\n// Checks whether `node` has a comment (that starts) on the same line as `node`\n// (ends).\nexport const getCommentAfter = (\n  node: T.Node,\n  sourceCode: TSESLint.SourceCode\n): T.Comment | undefined =>\n  sourceCode\n    .getCommentsAfter(node)\n    .find((comment) => comment.loc!.start.line === node.loc!.end.line);\n\nexport const trackImports = (fromModule = /^solid-js(?:\\/?|\\b)/) => {\n  const importMap = new Map<string, string>();\n  const handleImportDeclaration = (node: T.ImportDeclaration) => {\n    if (fromModule.test(node.source.value)) {\n      for (const specifier of node.specifiers) {\n        if (specifier.type === \"ImportSpecifier\") {\n          importMap.set(specifier.imported.name, specifier.local.name);\n        }\n      }\n    }\n  };\n  const matchImport = (imports: string | Array<string>, str: string): string | undefined => {\n    const importArr = Array.isArray(imports) ? imports : [imports];\n    return importArr.find((i) => importMap.get(i) === str);\n  };\n  return { matchImport, handleImportDeclaration };\n};\n\nexport function appendImports(\n  fixer: TSESLint.RuleFixer,\n  sourceCode: TSESLint.SourceCode,\n  importNode: T.ImportDeclaration,\n  identifiers: Array<string>\n): TSESLint.RuleFix | null {\n  const identifiersString = identifiers.join(\", \");\n  const reversedSpecifiers = importNode.specifiers.slice().reverse();\n  const lastSpecifier = reversedSpecifiers.find((s) => s.type === \"ImportSpecifier\");\n  if (lastSpecifier) {\n    // import A, { B } from 'source' => import A, { B, C, D } from 'source'\n    // import { B } from 'source' => import { B, C, D } from 'source'\n    return fixer.insertTextAfter(lastSpecifier, `, ${identifiersString}`);\n  }\n  const otherSpecifier = importNode.specifiers.find(\n    (s) => s.type === \"ImportDefaultSpecifier\" || s.type === \"ImportNamespaceSpecifier\"\n  );\n  if (otherSpecifier) {\n    // import A from 'source' => import A, { B, C, D } from 'source'\n    return fixer.insertTextAfter(otherSpecifier, `, { ${identifiersString} }`);\n  }\n  if (importNode.specifiers.length === 0) {\n    const [importToken, maybeBrace] = sourceCode.getFirstTokens(importNode, { count: 2 });\n    if (maybeBrace?.value === \"{\") {\n      // import {} from 'source' => import { B, C, D } from 'source'\n      return fixer.insertTextAfter(maybeBrace, ` ${identifiersString} `);\n    } else {\n      // import 'source' => import { B, C, D } from 'source'\n      return importToken\n        ? fixer.insertTextAfter(importToken, ` { ${identifiersString} } from`)\n        : null;\n    }\n  }\n  return null;\n}\nexport function insertImports(\n  fixer: TSESLint.RuleFixer,\n  sourceCode: TSESLint.SourceCode,\n  source: string,\n  identifiers: Array<string>,\n  aboveImport?: T.ImportDeclaration,\n  isType = false\n): TSESLint.RuleFix {\n  const identifiersString = identifiers.join(\", \");\n  const programNode: T.Program = sourceCode.ast;\n\n  // insert `import { missing, identifiers } from \"source\"` above given node or at top of module\n  const firstImport = aboveImport ?? programNode.body.find((n) => n.type === \"ImportDeclaration\");\n  if (firstImport) {\n    return fixer.insertTextBeforeRange(\n      (getCommentBefore(firstImport, sourceCode) ?? firstImport).range,\n      `import ${isType ? \"type \" : \"\"}{ ${identifiersString} } from \"${source}\";\\n`\n    );\n  }\n  return fixer.insertTextBeforeRange(\n    [0, 0],\n    `import ${isType ? \"type \" : \"\"}{ ${identifiersString} } from \"${source}\";\\n`\n  );\n}\n\nexport function removeSpecifier(\n  fixer: TSESLint.RuleFixer,\n  sourceCode: TSESLint.SourceCode,\n  specifier: T.ImportSpecifier,\n  pure = true\n) {\n  const declaration = specifier.parent as T.ImportDeclaration;\n  if (declaration.specifiers.length === 1 && pure) {\n    return fixer.remove(declaration);\n  }\n  const maybeComma = sourceCode.getTokenAfter(specifier);\n  if (maybeComma?.value === \",\") {\n    return fixer.removeRange([specifier.range[0], maybeComma.range[1]]);\n  }\n  return fixer.remove(specifier);\n}\n\nexport function jsxPropName(prop: T.JSXAttribute) {\n  if (prop.name.type === \"JSXNamespacedName\") {\n    return `${prop.name.namespace.name}:${prop.name.name.name}`;\n  }\n\n  return prop.name.name;\n}\n\ntype Props = T.JSXOpeningElement[\"attributes\"];\n\n/** Iterate through both attributes and spread object props, yielding the name and the node. */\nexport function* jsxGetAllProps(props: Props): Generator<[string, T.Node]> {\n  for (const attr of props) {\n    if (attr.type === \"JSXSpreadAttribute\" && attr.argument.type === \"ObjectExpression\") {\n      for (const property of attr.argument.properties) {\n        if (property.type === \"Property\") {\n          if (property.key.type === \"Identifier\") {\n            yield [property.key.name, property.key];\n          } else if (property.key.type === \"Literal\") {\n            yield [String(property.key.value), property.key];\n          }\n        }\n      }\n    } else if (attr.type === \"JSXAttribute\") {\n      yield [jsxPropName(attr), attr.name];\n    }\n  }\n}\n\n/** Returns whether an element has a prop, checking spread object props. */\nexport function jsxHasProp(props: Props, prop: string) {\n  for (const [p] of jsxGetAllProps(props)) {\n    if (p === prop) return true;\n  }\n  return false;\n}\n\n/** Get a JSXAttribute, excluding spread props. */\nexport function jsxGetProp(props: Props, prop: string) {\n  return props.find(\n    (attribute) => attribute.type !== \"JSXSpreadAttribute\" && prop === jsxPropName(attribute)\n  ) as T.JSXAttribute | undefined;\n}\n","/**\n * FIXME: remove this comments and import when below issue is fixed.\n * This import is necessary for type generation due to a bug in the TypeScript compiler.\n * See: https://github.com/microsoft/TypeScript/issues/42873\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { TSESLint } from \"@typescript-eslint/utils\";\n\nimport { TSESTree as T, ESLintUtils, ASTUtils } from \"@typescript-eslint/utils\";\nimport { isDOMElementName } from \"../utils\";\nimport { getScope, getSourceCode } from \"../compat\";\n\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\nconst { getStaticValue } = ASTUtils;\n\nconst COMMON_EVENTS = [\n  \"onAnimationEnd\",\n  \"onAnimationIteration\",\n  \"onAnimationStart\",\n  \"onBeforeInput\",\n  \"onBlur\",\n  \"onChange\",\n  \"onClick\",\n  \"onContextMenu\",\n  \"onCopy\",\n  \"onCut\",\n  \"onDblClick\",\n  \"onDrag\",\n  \"onDragEnd\",\n  \"onDragEnter\",\n  \"onDragExit\",\n  \"onDragLeave\",\n  \"onDragOver\",\n  \"onDragStart\",\n  \"onDrop\",\n  \"onError\",\n  \"onFocus\",\n  \"onFocusIn\",\n  \"onFocusOut\",\n  \"onGotPointerCapture\",\n  \"onInput\",\n  \"onInvalid\",\n  \"onKeyDown\",\n  \"onKeyPress\",\n  \"onKeyUp\",\n  \"onLoad\",\n  \"onLostPointerCapture\",\n  \"onMouseDown\",\n  \"onMouseEnter\",\n  \"onMouseLeave\",\n  \"onMouseMove\",\n  \"onMouseOut\",\n  \"onMouseOver\",\n  \"onMouseUp\",\n  \"onPaste\",\n  \"onPointerCancel\",\n  \"onPointerDown\",\n  \"onPointerEnter\",\n  \"onPointerLeave\",\n  \"onPointerMove\",\n  \"onPointerOut\",\n  \"onPointerOver\",\n  \"onPointerUp\",\n  \"onReset\",\n  \"onScroll\",\n  \"onSelect\",\n  \"onSubmit\",\n  \"onToggle\",\n  \"onTouchCancel\",\n  \"onTouchEnd\",\n  \"onTouchMove\",\n  \"onTouchStart\",\n  \"onTransitionEnd\",\n  \"onWheel\",\n] as const;\ntype CommonEvent = (typeof COMMON_EVENTS)[number];\n\nconst COMMON_EVENTS_MAP = new Map<string, CommonEvent>(\n  (function* () {\n    for (const event of COMMON_EVENTS) {\n      yield [event.toLowerCase(), event] as const;\n    }\n  })()\n);\n\nconst NONSTANDARD_EVENTS_MAP = {\n  ondoubleclick: \"onDblClick\",\n};\n\nconst isCommonHandlerName = (\n  lowercaseHandlerName: string\n): lowercaseHandlerName is Lowercase<CommonEvent> => COMMON_EVENTS_MAP.has(lowercaseHandlerName);\nconst getCommonEventHandlerName = (lowercaseHandlerName: Lowercase<CommonEvent>): CommonEvent =>\n  COMMON_EVENTS_MAP.get(lowercaseHandlerName)!;\n\nconst isNonstandardEventName = (\n  lowercaseEventName: string\n): lowercaseEventName is keyof typeof NONSTANDARD_EVENTS_MAP =>\n  Boolean((NONSTANDARD_EVENTS_MAP as Record<string, string>)[lowercaseEventName]);\nconst getStandardEventHandlerName = (lowercaseEventName: keyof typeof NONSTANDARD_EVENTS_MAP) =>\n  NONSTANDARD_EVENTS_MAP[lowercaseEventName];\n\ntype MessageIds =\n  | \"naming\"\n  | \"capitalization\"\n  | \"nonstandard\"\n  | \"make-handler\"\n  | \"make-attr\"\n  | \"detected-attr\"\n  | \"spread-handler\";\ntype Options = [{ ignoreCase?: boolean; warnOnSpread?: boolean }?];\n\nexport default createRule<Options, MessageIds>({\n  meta: {\n    type: \"problem\",\n    docs: {\n      description:\n        \"Enforce naming DOM element event handlers consistently and prevent Solid's analysis from misunderstanding whether a prop should be an event handler.\",\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/event-handlers.md\",\n    },\n    fixable: \"code\",\n    hasSuggestions: true,\n    schema: [\n      {\n        type: \"object\",\n        properties: {\n          ignoreCase: {\n            type: \"boolean\",\n            description:\n              \"if true, don't warn on ambiguously named event handlers like `onclick` or `onchange`\",\n            default: false,\n          },\n          warnOnSpread: {\n            type: \"boolean\",\n            description:\n              \"if true, warn when spreading event handlers onto JSX. Enable for Solid < v1.6.\",\n            default: false,\n          },\n        },\n        additionalProperties: false,\n      },\n    ],\n    messages: {\n      \"detected-attr\":\n        'The {{name}} prop is named as an event handler (starts with \"on\"), but Solid knows its value ({{staticValue}}) is a string or number, so it will be treated as an attribute. If this is intentional, name this prop attr:{{name}}.',\n      naming:\n        \"The {{name}} prop is ambiguous. If it is an event handler, change it to {{handlerName}}. If it is an attribute, change it to {{attrName}}.\",\n      capitalization: \"The {{name}} prop should be renamed to {{fixedName}} for readability.\",\n      nonstandard:\n        \"The {{name}} prop should be renamed to {{fixedName}}, because it's not a standard event handler.\",\n      \"make-handler\": \"Change the {{name}} prop to {{handlerName}}.\",\n      \"make-attr\": \"Change the {{name}} prop to {{attrName}}.\",\n      \"spread-handler\":\n        \"The {{name}} prop should be added as a JSX attribute, not spread in. Solid doesn't add listeners when spreading into JSX.\",\n    },\n  },\n  defaultOptions: [],\n  create(context) {\n    const sourceCode = getSourceCode(context);\n\n    return {\n      JSXAttribute(node) {\n        const openingElement = node.parent as T.JSXOpeningElement;\n        if (\n          openingElement.name.type !== \"JSXIdentifier\" ||\n          !isDOMElementName(openingElement.name.name)\n        ) {\n          return; // bail if this is not a DOM/SVG element or web component\n        }\n\n        if (node.name.type === \"JSXNamespacedName\") {\n          return; // bail early on attr:, on:, oncapture:, etc. props\n        }\n\n        // string name of the name node\n        const { name } = node.name;\n\n        if (!/^on[a-zA-Z]/.test(name)) {\n          return; // bail if Solid doesn't consider the prop name an event handler\n        }\n\n        let staticValue: ReturnType<typeof getStaticValue> = null;\n        if (\n          node.value?.type === \"JSXExpressionContainer\" &&\n          node.value.expression.type !== \"JSXEmptyExpression\" &&\n          node.value.expression.type !== \"ArrayExpression\" && // array syntax prevents inlining\n          (staticValue = getStaticValue(node.value.expression, getScope(context, node))) !== null &&\n          (typeof staticValue.value === \"string\" || typeof staticValue.value === \"number\")\n        ) {\n          // One of the first things Solid (actually babel-plugin-dom-expressions) does with an\n          // attribute is determine if it can be inlined into a template string instead of\n          // injected programmatically. It runs\n          // `attribute.get(\"value\").get(\"expression\").evaluate().value` on attributes with\n          // JSXExpressionContainers, and if the statically evaluated value is a string or number,\n          // it inlines it. This runs even for attributes that follow the naming convention for\n          // event handlers. By starting an attribute name with \"on\", the user has signalled that\n          // they intend the attribute to be an event handler. If the attribute value would be\n          // inlined, report that.\n          // https://github.com/ryansolid/dom-expressions/blob/cb3be7558c731e2a442e9c7e07d25373c40cf2be/packages/babel-plugin-jsx-dom-expressions/src/dom/element.js#L347\n          context.report({\n            node,\n            messageId: \"detected-attr\",\n            data: {\n              name,\n              staticValue: staticValue.value,\n            },\n          });\n        } else if (node.value === null || node.value?.type === \"Literal\") {\n          // Check for same as above for literal values\n          context.report({\n            node,\n            messageId: \"detected-attr\",\n            data: {\n              name,\n              staticValue: node.value !== null ? node.value.value : true,\n            },\n          });\n        } else if (!context.options[0]?.ignoreCase) {\n          const lowercaseHandlerName = name.toLowerCase();\n          if (isNonstandardEventName(lowercaseHandlerName)) {\n            const fixedName = getStandardEventHandlerName(lowercaseHandlerName);\n            context.report({\n              node: node.name,\n              messageId: \"nonstandard\",\n              data: { name, fixedName },\n              fix: (fixer) => fixer.replaceText(node.name, fixedName),\n            });\n          } else if (isCommonHandlerName(lowercaseHandlerName)) {\n            const fixedName = getCommonEventHandlerName(lowercaseHandlerName);\n            if (fixedName !== name) {\n              // For common DOM event names, we know the user intended the prop to be an event handler.\n              // Fix it to have an uppercase third letter and be properly camel-cased.\n              context.report({\n                node: node.name,\n                messageId: \"capitalization\",\n                data: { name, fixedName },\n                fix: (fixer) => fixer.replaceText(node.name, fixedName),\n              });\n            }\n          } else if (name[2] === name[2].toLowerCase()) {\n            // this includes words like `only` and `ongoing` as well as unknown handlers like `onfoobar`.\n            // Enforce using either /^on[A-Z]/ (event handler) or /^attr:on[a-z]/ (forced regular attribute)\n            // to make user intent clear and code maximally readable\n            const handlerName = `on${name[2].toUpperCase()}${name.slice(3)}`;\n            const attrName = `attr:${name}`;\n            context.report({\n              node: node.name,\n              messageId: \"naming\",\n              data: { name, attrName, handlerName },\n              suggest: [\n                {\n                  messageId: \"make-handler\",\n                  data: { name, handlerName },\n                  fix: (fixer) => fixer.replaceText(node.name, handlerName),\n                },\n                {\n                  messageId: \"make-attr\",\n                  data: { name, attrName },\n                  fix: (fixer) => fixer.replaceText(node.name, attrName),\n                },\n              ],\n            });\n          }\n        }\n      },\n      Property(node: T.Property) {\n        if (\n          context.options[0]?.warnOnSpread &&\n          node.parent?.type === \"ObjectExpression\" &&\n          node.parent.parent?.type === \"JSXSpreadAttribute\" &&\n          node.parent.parent.parent?.type === \"JSXOpeningElement\"\n        ) {\n          const openingElement = node.parent.parent.parent;\n          if (\n            openingElement.name.type === \"JSXIdentifier\" &&\n            isDOMElementName(openingElement.name.name)\n          ) {\n            if (node.key.type === \"Identifier\" && /^on/.test(node.key.name)) {\n              const handlerName = node.key.name;\n              // An event handler is being spread in (ex. <button {...{ onClick }} />), which doesn't\n              // actually add an event listener, just a plain attribute.\n              context.report({\n                node,\n                messageId: \"spread-handler\",\n                data: {\n                  name: node.key.name,\n                },\n                *fix(fixer) {\n                  const commaAfter = sourceCode.getTokenAfter(node);\n                  yield fixer.remove(\n                    (node.parent as T.ObjectExpression).properties.length === 1\n                      ? node.parent!.parent!\n                      : node\n                  );\n                  if (commaAfter?.value === \",\") {\n                    yield fixer.remove(commaAfter);\n                  }\n                  yield fixer.insertTextAfter(\n                    node.parent!.parent!,\n                    ` ${handlerName}={${sourceCode.getText(node.value)}}`\n                  );\n                },\n              });\n            }\n          }\n        }\n      },\n    };\n  },\n});\n","import { TSESTree as T, TSESLint, ESLintUtils } from \"@typescript-eslint/utils\";\nimport { appendImports, insertImports, removeSpecifier } from \"../utils\";\nimport { getSourceCode } from \"../compat\";\n\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\n\n// Below: create maps of imports and types to designated import source.\n// We could mess with `Object.keys(require(\"solid-js\"))` to generate this, but requiring it from\n// node activates the \"node\" export condition, which doesn't necessarily match what users will\n// receive i.e. through bundlers. Instead, we're manually listing all of the public exports that\n// should be imported from \"solid-js\", etc.\n// ==============\n\ntype Source = \"solid-js\" | \"solid-js/web\" | \"solid-js/store\";\n\n// Set up map of imports to module\nconst primitiveMap = new Map<string, Source>();\nfor (const primitive of [\n  \"createSignal\",\n  \"createEffect\",\n  \"createMemo\",\n  \"createResource\",\n  \"onMount\",\n  \"onCleanup\",\n  \"onError\",\n  \"untrack\",\n  \"batch\",\n  \"on\",\n  \"createRoot\",\n  \"getOwner\",\n  \"runWithOwner\",\n  \"mergeProps\",\n  \"splitProps\",\n  \"useTransition\",\n  \"observable\",\n  \"from\",\n  \"mapArray\",\n  \"indexArray\",\n  \"createContext\",\n  \"useContext\",\n  \"children\",\n  \"lazy\",\n  \"createUniqueId\",\n  \"createDeferred\",\n  \"createRenderEffect\",\n  \"createComputed\",\n  \"createReaction\",\n  \"createSelector\",\n  \"DEV\",\n  \"For\",\n  \"Show\",\n  \"Switch\",\n  \"Match\",\n  \"Index\",\n  \"ErrorBoundary\",\n  \"Suspense\",\n  \"SuspenseList\",\n]) {\n  primitiveMap.set(primitive, \"solid-js\");\n}\nfor (const primitive of [\n  \"Portal\",\n  \"render\",\n  \"hydrate\",\n  \"renderToString\",\n  \"renderToStream\",\n  \"isServer\",\n  \"renderToStringAsync\",\n  \"generateHydrationScript\",\n  \"HydrationScript\",\n  \"Dynamic\",\n]) {\n  primitiveMap.set(primitive, \"solid-js/web\");\n}\nfor (const primitive of [\n  \"createStore\",\n  \"produce\",\n  \"reconcile\",\n  \"unwrap\",\n  \"createMutable\",\n  \"modifyMutable\",\n]) {\n  primitiveMap.set(primitive, \"solid-js/store\");\n}\n\n// Set up map of type imports to module\nconst typeMap = new Map<string, Source>();\nfor (const type of [\n  \"Signal\",\n  \"Accessor\",\n  \"Setter\",\n  \"Resource\",\n  \"ResourceActions\",\n  \"ResourceOptions\",\n  \"ResourceReturn\",\n  \"ResourceFetcher\",\n  \"InitializedResourceReturn\",\n  \"Component\",\n  \"VoidProps\",\n  \"VoidComponent\",\n  \"ParentProps\",\n  \"ParentComponent\",\n  \"FlowProps\",\n  \"FlowComponent\",\n  \"ValidComponent\",\n  \"ComponentProps\",\n  \"Ref\",\n  \"MergeProps\",\n  \"SplitPrips\",\n  \"Context\",\n  \"JSX\",\n  \"ResolvedChildren\",\n  \"MatchProps\",\n]) {\n  typeMap.set(type, \"solid-js\");\n}\nfor (const type of [/* \"JSX\", */ \"MountableElement\"]) {\n  typeMap.set(type, \"solid-js/web\");\n}\nfor (const type of [\"StoreNode\", \"Store\", \"SetStoreFunction\"]) {\n  typeMap.set(type, \"solid-js/store\");\n}\n\nconst sourceRegex = /^solid-js(?:\\/web|\\/store)?$/;\nconst isSource = (source: string): source is Source => sourceRegex.test(source);\n\nexport default createRule({\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description:\n        'Enforce consistent imports from \"solid-js\", \"solid-js/web\", and \"solid-js/store\".',\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/imports.md\",\n    },\n    fixable: \"code\",\n    schema: [],\n    messages: {\n      \"prefer-source\": 'Prefer importing {{name}} from \"{{source}}\".',\n    },\n  },\n  defaultOptions: [],\n  create(context) {\n    return {\n      ImportDeclaration(node) {\n        const source = node.source.value;\n        if (!isSource(source)) return;\n\n        for (const specifier of node.specifiers) {\n          if (specifier.type === \"ImportSpecifier\") {\n            const isType = specifier.importKind === \"type\" || node.importKind === \"type\";\n            const map = isType ? typeMap : primitiveMap;\n            const correctSource = map.get(specifier.imported.name);\n            if (correctSource != null && correctSource !== source) {\n              context.report({\n                node: specifier,\n                messageId: \"prefer-source\",\n                data: {\n                  name: specifier.imported.name,\n                  source: correctSource,\n                },\n                fix(fixer) {\n                  const sourceCode = getSourceCode(context);\n                  const program: T.Program = sourceCode.ast;\n                  const correctDeclaration = program.body.find(\n                    (node) =>\n                      node.type === \"ImportDeclaration\" && node.source.value === correctSource\n                  ) as T.ImportDeclaration | undefined;\n\n                  if (correctDeclaration) {\n                    return [\n                      removeSpecifier(fixer, sourceCode, specifier),\n                      appendImports(fixer, sourceCode, correctDeclaration, [\n                        sourceCode.getText(specifier),\n                      ]),\n                    ].filter(Boolean) as Array<TSESLint.RuleFix>;\n                  }\n\n                  const firstSolidDeclaration = program.body.find(\n                    (node) => node.type === \"ImportDeclaration\" && isSource(node.source.value)\n                  ) as T.ImportDeclaration | undefined;\n                  return [\n                    removeSpecifier(fixer, sourceCode, specifier),\n                    insertImports(\n                      fixer,\n                      sourceCode,\n                      correctSource,\n                      [sourceCode.getText(specifier)],\n                      firstSolidDeclaration,\n                      isType\n                    ),\n                  ];\n                },\n              });\n            }\n          }\n        }\n      },\n    };\n  },\n});\n","/**\n * FIXME: remove this comments and import when below issue is fixed.\n * This import is necessary for type generation due to a bug in the TypeScript compiler.\n * See: https://github.com/microsoft/TypeScript/issues/42873\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { TSESLint } from \"@typescript-eslint/utils\";\n\nimport { TSESTree as T, ESLintUtils } from \"@typescript-eslint/utils\";\nimport { jsxGetAllProps } from \"../utils\";\n\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\n\n/*\n * This rule is adapted from eslint-plugin-react's jsx-no-duplicate-props rule under\n * the MIT license, with some enhancements. Thank you for your work!\n */\n\ntype MessageIds = \"noDuplicateProps\" | \"noDuplicateClass\" | \"noDuplicateChildren\";\ntype Options = [{ ignoreCase?: boolean }?];\n\nexport default createRule<Options, MessageIds>({\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow passing the same prop twice in JSX.\",\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/jsx-no-duplicate-props.md\",\n    },\n    schema: [\n      {\n        type: \"object\",\n        properties: {\n          ignoreCase: {\n            type: \"boolean\",\n            description: \"Consider two prop names differing only by case to be the same.\",\n            default: false,\n          },\n        },\n      },\n    ],\n    messages: {\n      noDuplicateProps: \"Duplicate props are not allowed.\",\n      noDuplicateClass:\n        \"Duplicate `class` props are not allowed; while it might seem to work, it can break unexpectedly. Use `classList` instead.\",\n      noDuplicateChildren: \"Using {{used}} at the same time is not allowed.\",\n    },\n  },\n  defaultOptions: [],\n  create(context) {\n    return {\n      JSXOpeningElement(node) {\n        const ignoreCase = context.options[0]?.ignoreCase ?? false;\n        const props = new Set();\n        const checkPropName = (name: string, node: T.Node) => {\n          if (ignoreCase || name.startsWith(\"on\")) {\n            name = name\n              .toLowerCase()\n              .replace(/^on(?:capture)?:/, \"on\")\n              .replace(/^(?:attr|prop):/, \"\");\n          }\n          if (props.has(name)) {\n            context.report({\n              node,\n              messageId: name === \"class\" ? \"noDuplicateClass\" : \"noDuplicateProps\",\n            });\n          }\n          props.add(name);\n        };\n\n        for (const [name, propNode] of jsxGetAllProps(node.attributes)) {\n          checkPropName(name, propNode);\n        }\n\n        const hasChildrenProp = props.has(\"children\");\n        const hasChildren = (node.parent as T.JSXElement | T.JSXFragment).children.length > 0;\n        const hasInnerHTML = props.has(\"innerHTML\") || props.has(\"innerhtml\");\n        const hasTextContent = props.has(\"textContent\") || props.has(\"textContent\");\n        const used = [\n          hasChildrenProp && \"`props.children`\",\n          hasChildren && \"JSX children\",\n          hasInnerHTML && \"`props.innerHTML`\",\n          hasTextContent && \"`props.textContent`\",\n        ].filter(Boolean);\n        if (used.length > 1) {\n          context.report({\n            node,\n            messageId: \"noDuplicateChildren\",\n            data: {\n              used: used.join(\", \"),\n            },\n          });\n        }\n      },\n    };\n  },\n});\n","/**\n * FIXME: remove this comments and import when below issue is fixed.\n * This import is necessary for type generation due to a bug in the TypeScript compiler.\n * See: https://github.com/microsoft/TypeScript/issues/42873\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { TSESLint } from \"@typescript-eslint/utils\";\n\nimport { ESLintUtils, ASTUtils } from \"@typescript-eslint/utils\";\nimport { getScope } from \"../compat\";\n\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\nconst { getStaticValue }: { getStaticValue: any } = ASTUtils;\n\n// A javascript: URL can contain leading C0 control or \\u0020 SPACE,\n// and any newline or tab are filtered out as if they're not part of the URL.\n// https://url.spec.whatwg.org/#url-parsing\n// Tab or newline are defined as \\r\\n\\t:\n// https://infra.spec.whatwg.org/#ascii-tab-or-newline\n// A C0 control is a code point in the range \\u0000 NULL to \\u001F\n// INFORMATION SEPARATOR ONE, inclusive:\n// https://infra.spec.whatwg.org/#c0-control-or-space\nconst isJavaScriptProtocol =\n  /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*:/i; // eslint-disable-line no-control-regex\n\n/**\n * This rule is adapted from eslint-plugin-react's jsx-no-script-url rule under the MIT license.\n * Thank you for your work!\n */\nexport default createRule({\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow javascript: URLs.\",\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/jsx-no-script-url.md\",\n    },\n    schema: [],\n    messages: {\n      noJSURL: \"For security, don't use javascript: URLs. Use event handlers instead if you can.\",\n    },\n  },\n  defaultOptions: [],\n  create(context) {\n    return {\n      JSXAttribute(node) {\n        if (node.name.type === \"JSXIdentifier\" && node.value) {\n          const link: { value: unknown } | null = getStaticValue(\n            node.value.type === \"JSXExpressionContainer\" ? node.value.expression : node.value,\n            getScope(context, node)\n          );\n          if (link && typeof link.value === \"string\" && isJavaScriptProtocol.test(link.value)) {\n            context.report({\n              node: node.value,\n              messageId: \"noJSURL\",\n            });\n          }\n        }\n      },\n    };\n  },\n});\n","/**\n * FIXME: remove this comments and import when below issue is fixed.\n * This import is necessary for type generation due to a bug in the TypeScript compiler.\n * See: https://github.com/microsoft/TypeScript/issues/42873\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { TSESLint } from \"@typescript-eslint/utils\";\n\nimport { TSESTree as T, ESLintUtils } from \"@typescript-eslint/utils\";\nimport { isDOMElementName, formatList, appendImports, insertImports } from \"../utils\";\nimport { getScope, getSourceCode } from \"../compat\";\n\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\n\n// Currently all of the control flow components are from 'solid-js'.\nconst AUTO_COMPONENTS = [\"Show\", \"For\", \"Index\", \"Switch\", \"Match\"];\nconst SOURCE_MODULE = \"solid-js\";\n\n/*\n * This rule is adapted from eslint-plugin-react's jsx-no-undef rule under\n * the MIT license. Thank you for your work!\n */\ntype MessageIds = \"undefined\" | \"customDirectiveUndefined\" | \"autoImport\";\ntype Options = [\n  {\n    allowGlobals?: boolean;\n    autoImport?: boolean;\n    typescriptEnabled?: boolean;\n  }?\n];\nexport default createRule<Options, MessageIds>({\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow references to undefined variables in JSX. Handles custom directives.\",\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/jsx-no-undef.md\",\n    },\n    fixable: \"code\",\n    schema: [\n      {\n        type: \"object\",\n        properties: {\n          allowGlobals: {\n            type: \"boolean\",\n            description:\n              \"When true, the rule will consider the global scope when checking for defined components.\",\n            default: false,\n          },\n          autoImport: {\n            type: \"boolean\",\n            description:\n              'Automatically import certain components from `\"solid-js\"` if they are undefined.',\n            default: true,\n          },\n          typescriptEnabled: {\n            type: \"boolean\",\n            description: \"Adjusts behavior not to conflict with TypeScript's type checking.\",\n            default: false,\n          },\n        },\n        additionalProperties: false,\n      },\n    ],\n    messages: {\n      undefined: \"'{{identifier}}' is not defined.\",\n      customDirectiveUndefined: \"Custom directive '{{identifier}}' is not defined.\",\n      autoImport: \"{{imports}} should be imported from '{{source}}'.\",\n    },\n  },\n  defaultOptions: [],\n  create(context) {\n    const allowGlobals = context.options[0]?.allowGlobals ?? false;\n    const autoImport = context.options[0]?.autoImport !== false;\n    const isTypeScriptEnabled = context.options[0]?.typescriptEnabled ?? false;\n\n    const missingComponentsSet = new Set<string>();\n\n    /**\n     * Compare an identifier with the variables declared in the scope\n     * @param {ASTNode} node - Identifier or JSXIdentifier node\n     * @returns {void}\n     */\n    function checkIdentifierInJSX(\n      node: T.Identifier | T.JSXIdentifier,\n      {\n        isComponent,\n        isCustomDirective,\n      }: { isComponent?: boolean; isCustomDirective?: boolean } = {}\n    ) {\n      let scope = getScope(context, node);\n      const sourceCode = getSourceCode(context);\n      const sourceType = sourceCode.ast.sourceType;\n      const scopeUpperBound = !allowGlobals && sourceType === \"module\" ? \"module\" : \"global\";\n      const variables = [...scope.variables];\n\n      // Ignore 'this' keyword (also maked as JSXIdentifier when used in JSX)\n      if (node.name === \"this\") {\n        return;\n      }\n\n      while (scope.type !== scopeUpperBound && scope.type !== \"global\" && scope.upper) {\n        scope = scope.upper;\n        variables.push(...scope.variables);\n      }\n      if (scope.childScopes.length) {\n        variables.push(...scope.childScopes[0].variables);\n        // Temporary fix for babel-eslint\n        if (scope.childScopes[0].childScopes.length) {\n          variables.push(...scope.childScopes[0].childScopes[0].variables);\n        }\n      }\n\n      if (variables.find((variable) => variable.name === node.name)) {\n        return;\n      }\n\n      if (\n        isComponent &&\n        autoImport &&\n        AUTO_COMPONENTS.includes(node.name) &&\n        !missingComponentsSet.has(node.name)\n      ) {\n        // track which names are undefined\n        missingComponentsSet.add(node.name);\n      } else if (isCustomDirective) {\n        context.report({\n          node,\n          messageId: \"customDirectiveUndefined\",\n          data: {\n            identifier: node.name,\n          },\n        });\n      } else if (!isTypeScriptEnabled) {\n        context.report({\n          node,\n          messageId: \"undefined\",\n          data: {\n            identifier: node.name,\n          },\n        });\n      }\n    }\n\n    return {\n      JSXOpeningElement(node) {\n        let n: T.Node | undefined;\n        switch (node.name.type) {\n          case \"JSXIdentifier\":\n            if (!isDOMElementName(node.name.name)) {\n              checkIdentifierInJSX(node.name, { isComponent: true });\n            }\n            break;\n          case \"JSXMemberExpression\":\n            n = node.name;\n            do {\n              n = (n as any).object;\n            } while (n && n.type !== \"JSXIdentifier\");\n            if (n) {\n              checkIdentifierInJSX(n);\n            }\n            break;\n          default:\n            break;\n        }\n      },\n      \"JSXAttribute > JSXNamespacedName\": (node: T.JSXNamespacedName) => {\n        // <Element use:X /> applies the `X` custom directive to the element, where `X` must be an identifier in scope.\n        if (\n          node.namespace?.type === \"JSXIdentifier\" &&\n          node.namespace.name === \"use\" &&\n          node.name?.type === \"JSXIdentifier\"\n        ) {\n          checkIdentifierInJSX(node.name, { isCustomDirective: true });\n        }\n      },\n      \"Program:exit\": (programNode: T.Program) => {\n        // add in any auto import components used in the program\n        const missingComponents = Array.from(missingComponentsSet.values());\n        if (autoImport && missingComponents.length) {\n          const importNode = programNode.body.find(\n            (n) =>\n              n.type === \"ImportDeclaration\" &&\n              n.importKind !== \"type\" &&\n              n.source.type === \"Literal\" &&\n              n.source.value === SOURCE_MODULE\n          ) as T.ImportDeclaration | undefined;\n          if (importNode) {\n            context.report({\n              node: importNode,\n              messageId: \"autoImport\",\n              data: {\n                imports: formatList(missingComponents), // \"Show, For, and Switch\"\n                source: SOURCE_MODULE,\n              },\n              fix: (fixer) => {\n                return appendImports(fixer, getSourceCode(context), importNode, missingComponents);\n              },\n            });\n          } else {\n            context.report({\n              node: programNode,\n              messageId: \"autoImport\",\n              data: {\n                imports: formatList(missingComponents),\n                source: SOURCE_MODULE,\n              },\n              fix: (fixer) => {\n                // insert `import { missing, identifiers } from \"solid-js\"` at top of module\n                return insertImports(fixer, getSourceCode(context), \"solid-js\", missingComponents);\n              },\n            });\n          }\n        }\n      },\n    };\n  },\n});\n","/**\n * FIXME: remove this comments and import when below issue is fixed.\n * This import is necessary for type generation due to a bug in the TypeScript compiler.\n * See: https://github.com/microsoft/TypeScript/issues/42873\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { TSESLint } from \"@typescript-eslint/utils\";\n\nimport { TSESTree as T, ESLintUtils } from \"@typescript-eslint/utils\";\nimport { markVariableAsUsed } from \"../compat\";\n\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\n\n/*\n * This rule is lifted almost verbatim from eslint-plugin-react's\n * jsx-uses-vars rule under the MIT license. Thank you for your work!\n * Solid's custom directives are also handled.\n */\n\nexport default createRule({\n  meta: {\n    type: \"problem\",\n    docs: {\n      // eslint-disable-next-line eslint-plugin/require-meta-docs-description\n      description: \"Prevent variables used in JSX from being marked as unused.\",\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/jsx-uses-vars.md\",\n    },\n    schema: [],\n    // eslint-disable-next-line eslint-plugin/prefer-message-ids\n    messages: {},\n  },\n  defaultOptions: [],\n  create(context) {\n    return {\n      JSXOpeningElement(node) {\n        let parent: T.JSXTagNameExpression;\n        switch (node.name.type) {\n          case \"JSXNamespacedName\": // <Foo:Bar>\n            return;\n          case \"JSXIdentifier\": // <Foo>\n            markVariableAsUsed(context, node.name.name, node.name);\n            break;\n          case \"JSXMemberExpression\": // <Foo...Bar>\n            parent = node.name.object;\n            while (parent?.type === \"JSXMemberExpression\") {\n              parent = parent.object;\n            }\n            if (parent.type === \"JSXIdentifier\") {\n              markVariableAsUsed(context, parent.name, parent);\n            }\n            break;\n        }\n      },\n      \"JSXAttribute > JSXNamespacedName\": (node: T.JSXNamespacedName) => {\n        // <Element use:X /> applies the `X` custom directive to the element, where `X` must be an identifier in scope.\n        if (\n          node.namespace?.type === \"JSXIdentifier\" &&\n          node.namespace.name === \"use\" &&\n          node.name?.type === \"JSXIdentifier\"\n        ) {\n          markVariableAsUsed(context, node.name.name, node.name);\n        }\n      },\n    };\n  },\n});\n","import { TSESTree as T, TSESLint, ESLintUtils, ASTUtils } from \"@typescript-eslint/utils\";\nimport type { FunctionNode } from \"../utils\";\nimport { getSourceCode } from \"../compat\";\n\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\nconst { getStringIfConstant } = ASTUtils;\n\nconst getName = (node: T.Node): string | null => {\n  switch (node.type) {\n    case \"Literal\":\n      return typeof node.value === \"string\" ? node.value : null;\n    case \"Identifier\":\n      return node.name;\n    case \"AssignmentPattern\":\n      return getName(node.left);\n    default:\n      return getStringIfConstant(node);\n  }\n};\n\ninterface PropertyInfo {\n  real: T.Literal | T.Identifier | T.Expression;\n  var: string;\n  computed: boolean;\n  init: T.Expression | undefined;\n}\n\n// Given ({ 'hello-world': helloWorld = 5 }), returns { real: Literal('hello-world'), var: 'helloWorld', computed: false, init: Literal(5) }\nconst getPropertyInfo = (prop: T.Property): PropertyInfo | null => {\n  const valueName = getName(prop.value);\n  if (valueName !== null) {\n    return {\n      real: prop.key,\n      var: valueName,\n      computed: prop.computed,\n      init: prop.value.type === \"AssignmentPattern\" ? prop.value.right : undefined,\n    };\n  } else {\n    return null;\n  }\n};\n\nexport default createRule({\n  meta: {\n    type: \"problem\",\n    docs: {\n      description:\n        \"Disallow destructuring props. In Solid, props must be used with property accesses (`props.foo`) to preserve reactivity. This rule only tracks destructuring in the parameter list.\",\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/no-destructure.md\",\n    },\n    fixable: \"code\",\n    schema: [],\n    messages: {\n      noDestructure:\n        \"Destructuring component props breaks Solid's reactivity; use property access instead.\",\n      // noWriteToProps: \"Component props are readonly, writing to props is not supported.\",\n    },\n  },\n  defaultOptions: [],\n  create(context) {\n    const functionStack: Array<{\n      /** switched to true by :exit if JSX is detected in the current function */\n      hasJSX: boolean;\n    }> = [];\n    const currentFunction = () => functionStack[functionStack.length - 1];\n    const onFunctionEnter = () => {\n      functionStack.push({ hasJSX: false });\n    };\n    const onFunctionExit = (node: FunctionNode) => {\n      if (node.params.length === 1) {\n        const props = node.params[0];\n        if (\n          props.type === \"ObjectPattern\" &&\n          currentFunction().hasJSX &&\n          node.parent?.type !== \"JSXExpressionContainer\" // \"render props\" aren't components\n        ) {\n          // Props are destructured in the function params, not the body. We actually don't\n          // need to handle the case where props are destructured in the body, because that\n          // will be a violation of \"solid/reactivity\".\n          context.report({\n            node: props,\n            messageId: \"noDestructure\",\n            fix: (fixer) => fixDestructure(node, props, fixer),\n          });\n        }\n      }\n\n      // Pop on exit\n      functionStack.pop();\n    };\n\n    function* fixDestructure(\n      func: FunctionNode,\n      props: T.ObjectPattern,\n      fixer: TSESLint.RuleFixer\n    ): Generator<TSESLint.RuleFix> {\n      const propsName = \"props\";\n      const properties = props.properties;\n\n      const propertyInfo: Array<PropertyInfo> = [];\n      let rest: T.RestElement | null = null;\n\n      for (const property of properties) {\n        if (property.type === \"RestElement\") {\n          rest = property;\n        } else {\n          const info = getPropertyInfo(property);\n          if (info === null) {\n            continue;\n          }\n          propertyInfo.push(info);\n        }\n      }\n\n      const hasDefaults = propertyInfo.some((info) => info.init);\n\n      // Replace destructured props with a `props` identifier (`_props` in case of rest params/defaults)\n      const origProps = !(hasDefaults || rest) ? propsName : \"_\" + propsName;\n      if (props.typeAnnotation) {\n        // in `{ prop1, prop2 }: Props`, leave `: Props` alone\n        const range = [props.range[0], props.typeAnnotation.range[0]] as const;\n        yield fixer.replaceTextRange(range, origProps);\n      } else {\n        yield fixer.replaceText(props, origProps);\n      }\n\n      const sourceCode = getSourceCode(context);\n\n      const defaultsObjectString = () =>\n        propertyInfo\n          .filter((info) => info.init)\n          .map(\n            (info) =>\n              `${info.computed ? \"[\" : \"\"}${sourceCode.getText(info.real)}${\n                info.computed ? \"]\" : \"\"\n              }: ${sourceCode.getText(info.init)}`\n          )\n          .join(\", \");\n      const splitPropsArray = () =>\n        `[${propertyInfo\n          .map((info) =>\n            info.real.type === \"Identifier\"\n              ? JSON.stringify(info.real.name)\n              : sourceCode.getText(info.real)\n          )\n          .join(\", \")}]`;\n\n      let lineToInsert = \"\";\n      if (hasDefaults && rest) {\n        // Insert a line that assigns _props\n        lineToInsert = `  const [${propsName}, ${\n          (rest.argument.type === \"Identifier\" && rest.argument.name) || \"rest\"\n        }] = splitProps(mergeProps({ ${defaultsObjectString()} }, ${origProps}), ${splitPropsArray()});`;\n      } else if (hasDefaults) {\n        // Insert a line that assigns _props merged with defaults to props\n        lineToInsert = `  const ${propsName} = mergeProps({ ${defaultsObjectString()} }, ${origProps});\\n`;\n      } else if (rest) {\n        // Insert a line that keeps named props and extracts the rest into a new reactive rest object\n        lineToInsert = `  const [${propsName}, ${\n          (rest.argument.type === \"Identifier\" && rest.argument.name) || \"rest\"\n        }] = splitProps(${origProps}, ${splitPropsArray()});\\n`;\n      }\n\n      if (lineToInsert) {\n        const body = func.body;\n        if (body.type === \"BlockStatement\") {\n          if (body.body.length > 0) {\n            // Inject lines handling defaults/rest params before the first statement in the block.\n            yield fixer.insertTextBefore(body.body[0], lineToInsert);\n          }\n          // with an empty block statement body, no need to inject code\n        } else {\n          // The function is an arrow function that implicitly returns an expression, possibly with wrapping parentheses.\n          // These must be removed to convert the function body to a block statement for code injection.\n          const maybeOpenParen = sourceCode.getTokenBefore(body);\n          if (maybeOpenParen?.value === \"(\") {\n            yield fixer.remove(maybeOpenParen);\n          }\n          const maybeCloseParen = sourceCode.getTokenAfter(body);\n          if (maybeCloseParen?.value === \")\") {\n            yield fixer.remove(maybeCloseParen);\n          }\n\n          // Inject lines handling defaults/rest params\n          yield fixer.insertTextBefore(body, `{\\n${lineToInsert}  return (`);\n          yield fixer.insertTextAfter(body, `);\\n}`);\n        }\n      }\n\n      const scope = sourceCode.scopeManager?.acquire(func);\n      if (scope) {\n        // iterate through destructured variables, associated with real node\n        for (const [info, variable] of propertyInfo.map(\n          (info) => [info, scope.set.get(info.var)] as const\n        )) {\n          if (variable) {\n            // replace all usages of the variable with props accesses\n            for (const reference of variable.references) {\n              if (reference.isReadOnly()) {\n                const access =\n                  info.real.type === \"Identifier\" && !info.computed\n                    ? `.${info.real.name}`\n                    : `[${sourceCode.getText(info.real)}]`;\n                yield fixer.replaceText(reference.identifier, `${propsName}${access}`);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      FunctionDeclaration: onFunctionEnter,\n      FunctionExpression: onFunctionEnter,\n      ArrowFunctionExpression: onFunctionEnter,\n      \"FunctionDeclaration:exit\": onFunctionExit,\n      \"FunctionExpression:exit\": onFunctionExit,\n      \"ArrowFunctionExpression:exit\": onFunctionExit,\n      JSXElement() {\n        if (functionStack.length) {\n          currentFunction().hasJSX = true;\n        }\n      },\n      JSXFragment() {\n        if (functionStack.length) {\n          currentFunction().hasJSX = true;\n        }\n      },\n    };\n  },\n});\n","/**\n * FIXME: remove this comments and import when below issue is fixed.\n * This import is necessary for type generation due to a bug in the TypeScript compiler.\n * See: https://github.com/microsoft/TypeScript/issues/42873\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { TSESLint } from \"@typescript-eslint/utils\";\n\nimport { ESLintUtils, ASTUtils } from \"@typescript-eslint/utils\";\nimport isHtml from \"is-html\";\nimport { jsxPropName } from \"../utils\";\n\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\nconst { getStringIfConstant } = ASTUtils;\n\ntype MessageIds = \"dangerous\" | \"conflict\" | \"notHtml\" | \"useInnerText\" | \"dangerouslySetInnerHTML\";\ntype Options = [{ allowStatic?: boolean }?];\n\nexport default createRule<Options, MessageIds>({\n  meta: {\n    type: \"problem\",\n    docs: {\n      description:\n        \"Disallow usage of the innerHTML attribute, which can often lead to security vulnerabilities.\",\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/no-innerhtml.md\",\n    },\n    fixable: \"code\",\n    hasSuggestions: true,\n    schema: [\n      {\n        type: \"object\",\n        properties: {\n          allowStatic: {\n            description:\n              \"if the innerHTML value is guaranteed to be a static HTML string (i.e. no user input), allow it\",\n            type: \"boolean\",\n            default: true,\n          },\n        },\n        additionalProperties: false,\n      },\n    ],\n    messages: {\n      dangerous:\n        \"The innerHTML attribute is dangerous; passing unsanitized input can lead to security vulnerabilities.\",\n      conflict:\n        \"The innerHTML attribute should not be used on an element with child elements; they will be overwritten.\",\n      notHtml: \"The string passed to innerHTML does not appear to be valid HTML.\",\n      useInnerText: \"For text content, using innerText is clearer and safer.\",\n      dangerouslySetInnerHTML:\n        \"The dangerouslySetInnerHTML prop is not supported; use innerHTML instead.\",\n    },\n  },\n  defaultOptions: [{ allowStatic: true }],\n  create(context) {\n    const allowStatic = Boolean(context.options[0]?.allowStatic ?? true);\n    return {\n      JSXAttribute(node) {\n        if (jsxPropName(node) === \"dangerouslySetInnerHTML\") {\n          if (\n            node.value?.type === \"JSXExpressionContainer\" &&\n            node.value.expression.type === \"ObjectExpression\" &&\n            node.value.expression.properties.length === 1\n          ) {\n            const htmlProp = node.value.expression.properties[0];\n            if (\n              htmlProp.type === \"Property\" &&\n              htmlProp.key.type === \"Identifier\" &&\n              htmlProp.key.name === \"__html\"\n            ) {\n              context.report({\n                node,\n                messageId: \"dangerouslySetInnerHTML\",\n                fix: (fixer) => {\n                  const propRange = node.range;\n                  const valueRange = htmlProp.value.range;\n                  return [\n                    fixer.replaceTextRange([propRange[0], valueRange[0]], \"innerHTML={\"),\n                    fixer.replaceTextRange([valueRange[1], propRange[1]], \"}\"),\n                  ];\n                },\n              });\n            } else {\n              context.report({\n                node,\n                messageId: \"dangerouslySetInnerHTML\",\n              });\n            }\n          } else {\n            context.report({\n              node,\n              messageId: \"dangerouslySetInnerHTML\",\n            });\n          }\n          return;\n        } else if (jsxPropName(node) !== \"innerHTML\") {\n          return;\n        }\n\n        if (allowStatic) {\n          const innerHtmlNode =\n            node.value?.type === \"JSXExpressionContainer\" ? node.value.expression : node.value;\n          const innerHtml = innerHtmlNode && getStringIfConstant(innerHtmlNode);\n          if (typeof innerHtml === \"string\") {\n            if (isHtml(innerHtml)) {\n              // go up to enclosing JSXElement and check if it has children\n              if (\n                node.parent?.parent?.type === \"JSXElement\" &&\n                node.parent.parent.children?.length\n              ) {\n                context.report({\n                  node: node.parent.parent, // report error on JSXElement instead of JSXAttribute\n                  messageId: \"conflict\",\n                });\n              }\n            } else {\n              context.report({\n                node,\n                messageId: \"notHtml\",\n                suggest: [\n                  {\n                    fix: (fixer) => fixer.replaceText(node.name, \"innerText\"),\n                    messageId: \"useInnerText\",\n                  },\n                ],\n              });\n            }\n          } else {\n            context.report({\n              node,\n              messageId: \"dangerous\",\n            });\n          }\n        } else {\n          context.report({\n            node,\n            messageId: \"dangerous\",\n          });\n        }\n      },\n    };\n  },\n});\n","/**\n * FIXME: remove this comments and import when below issue is fixed.\n * This import is necessary for type generation due to a bug in the TypeScript compiler.\n * See: https://github.com/microsoft/TypeScript/issues/42873\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { TSESLint } from \"@typescript-eslint/utils\";\n\nimport { TSESTree as T, ESLintUtils } from \"@typescript-eslint/utils\";\nimport { isFunctionNode, trackImports, isPropsByName, trace } from \"../utils\";\n\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\n\nexport default createRule({\n  meta: {\n    type: \"problem\",\n    docs: {\n      description:\n        \"Disallow usage of APIs that use ES6 Proxies, only to target environments that don't support them.\",\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/no-proxy-apis.md\",\n    },\n    schema: [],\n    messages: {\n      noStore: \"Solid Store APIs use Proxies, which are incompatible with your target environment.\",\n      spreadCall:\n        \"Using a function call in JSX spread makes Solid use Proxies, which are incompatible with your target environment.\",\n      spreadMember:\n        \"Using a property access in JSX spread makes Solid use Proxies, which are incompatible with your target environment.\",\n      proxyLiteral: \"Proxies are incompatible with your target environment.\",\n      mergeProps:\n        \"If you pass a function to `mergeProps`, it will create a Proxy, which are incompatible with your target environment.\",\n    },\n  },\n  defaultOptions: [],\n  create(context) {\n    const { matchImport, handleImportDeclaration } = trackImports();\n\n    return {\n      ImportDeclaration(node) {\n        handleImportDeclaration(node); // track import aliases\n\n        const source = node.source.value;\n        if (source === \"solid-js/store\") {\n          context.report({\n            node,\n            messageId: \"noStore\",\n          });\n        }\n      },\n      \"JSXSpreadAttribute MemberExpression\"(node: T.MemberExpression) {\n        context.report({ node, messageId: \"spreadMember\" });\n      },\n      \"JSXSpreadAttribute CallExpression\"(node: T.CallExpression) {\n        context.report({ node, messageId: \"spreadCall\" });\n      },\n      CallExpression(node) {\n        if (node.callee.type === \"Identifier\") {\n          if (matchImport(\"mergeProps\", node.callee.name)) {\n            node.arguments\n              .filter((arg) => {\n                if (arg.type === \"SpreadElement\") return true;\n                const traced = trace(arg, context);\n                return (\n                  (traced.type === \"Identifier\" && !isPropsByName(traced.name)) ||\n                  isFunctionNode(traced)\n                );\n              })\n              .forEach((badArg) => {\n                context.report({\n                  node: badArg,\n                  messageId: \"mergeProps\",\n                });\n              });\n          }\n        } else if (node.callee.type === \"MemberExpression\") {\n          if (\n            node.callee.object.type === \"Identifier\" &&\n            node.callee.object.name === \"Proxy\" &&\n            node.callee.property.type === \"Identifier\" &&\n            node.callee.property.name === \"revocable\"\n          ) {\n            context.report({\n              node,\n              messageId: \"proxyLiteral\",\n            });\n          }\n        }\n      },\n      NewExpression(node) {\n        if (node.callee.type === \"Identifier\" && node.callee.name === \"Proxy\") {\n          context.report({ node, messageId: \"proxyLiteral\" });\n        }\n      },\n    };\n  },\n});\n","/**\n * FIXME: remove this comments and import when below issue is fixed.\n * This import is necessary for type generation due to a bug in the TypeScript compiler.\n * See: https://github.com/microsoft/TypeScript/issues/42873\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { TSESLint } from \"@typescript-eslint/utils\";\n\nimport { ESLintUtils } from \"@typescript-eslint/utils\";\nimport { isFunctionNode, trace, trackImports } from \"../utils\";\n\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\n\nexport default createRule({\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow usage of dependency arrays in `createEffect` and `createMemo`.\",\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/no-react-deps.md\",\n    },\n    fixable: \"code\",\n    schema: [],\n    messages: {\n      noUselessDep:\n        \"In Solid, `{{name}}` doesn't accept a dependency array because it automatically tracks its dependencies. If you really need to override the list of dependencies, use `on`.\",\n    },\n  },\n  defaultOptions: [],\n  create(context) {\n    /** Tracks imports from 'solid-js', handling aliases. */\n    const { matchImport, handleImportDeclaration } = trackImports();\n\n    return {\n      ImportDeclaration: handleImportDeclaration,\n      CallExpression(node) {\n        if (\n          node.callee.type === \"Identifier\" &&\n          matchImport([\"createEffect\", \"createMemo\"], node.callee.name) &&\n          node.arguments.length === 2 &&\n          node.arguments.every((arg) => arg.type !== \"SpreadElement\")\n        ) {\n          // grab both arguments, tracing any variables to their actual values if possible\n          const [arg0, arg1] = node.arguments.map((arg) => trace(arg, context));\n\n          if (isFunctionNode(arg0) && arg0.params.length === 0 && arg1.type === \"ArrayExpression\") {\n            // A second argument that looks like a dependency array was passed to\n            // createEffect/createMemo, and the inline function doesn't accept a parameter, so it\n            // can't just be an initial value.\n            context.report({\n              node: node.arguments[1], // if this is a variable, highlight the usage, not the initialization\n              messageId: \"noUselessDep\",\n              data: {\n                name: node.callee.name,\n              },\n              // remove dep array if it's given inline, otherwise don't fix\n              fix: arg1 === node.arguments[1] ? (fixer) => fixer.remove(arg1) : undefined,\n            });\n          }\n        }\n      },\n    };\n  },\n});\n","import { TSESLint, ESLintUtils } from \"@typescript-eslint/utils\";\nimport { isDOMElementName, jsxGetProp, jsxHasProp } from \"../utils\";\n\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\n\nconst reactSpecificProps = [\n  { from: \"className\", to: \"class\" },\n  { from: \"htmlFor\", to: \"for\" },\n];\n\nexport default createRule({\n  meta: {\n    type: \"problem\",\n    docs: {\n      description:\n        \"Disallow usage of React-specific `className`/`htmlFor` props, which were deprecated in v1.4.0.\",\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/no-react-specific-props.md\",\n    },\n    fixable: \"code\",\n    schema: [],\n    messages: {\n      prefer: \"Prefer the `{{ to }}` prop over the deprecated `{{ from }}` prop.\",\n      noUselessKey: \"Elements in a <For> or <Index> list do not need a key prop.\",\n    },\n  },\n  defaultOptions: [],\n  create(context) {\n    return {\n      JSXOpeningElement(node) {\n        for (const { from, to } of reactSpecificProps) {\n          const classNameAttribute = jsxGetProp(node.attributes, from);\n          if (classNameAttribute) {\n            // only auto-fix if there is no class prop defined\n            const fix = !jsxHasProp(node.attributes, to)\n              ? (fixer: TSESLint.RuleFixer) => fixer.replaceText(classNameAttribute.name, to)\n              : undefined;\n\n            context.report({\n              node: classNameAttribute,\n              messageId: \"prefer\",\n              data: { from, to },\n              fix,\n            });\n          }\n        }\n        if (node.name.type === \"JSXIdentifier\" && isDOMElementName(node.name.name)) {\n          const keyProp = jsxGetProp(node.attributes, \"key\");\n          if (keyProp) {\n            // no DOM element has a 'key' prop, so we can assert that this is a holdover from React.\n            context.report({\n              node: keyProp,\n              messageId: \"noUselessKey\",\n              fix: (fixer) => fixer.remove(keyProp),\n            });\n          }\n        }\n      },\n    };\n  },\n});\n","/**\n * FIXME: remove this comments and import when below issue is fixed.\n * This import is necessary for type generation due to a bug in the TypeScript compiler.\n * See: https://github.com/microsoft/TypeScript/issues/42873\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { TSESLint } from \"@typescript-eslint/utils\";\n\nimport { ESLintUtils, TSESTree as T } from \"@typescript-eslint/utils\";\nimport { isDOMElementName } from \"../utils\";\n\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\n\nconst knownNamespaces = [\"on\", \"oncapture\", \"use\", \"prop\", \"attr\", \"bool\"];\nconst styleNamespaces = [\"style\", \"class\"];\nconst otherNamespaces = [\"xmlns\", \"xlink\"];\n\ntype MessageIds = \"unknown\" | \"style\" | \"component\" | \"component-suggest\";\ntype Options = [{ allowedNamespaces: Array<string> }?];\n\nexport default createRule<Options, MessageIds>({\n  meta: {\n    type: \"problem\",\n    docs: {\n      description:\n        \"Enforce using only Solid-specific namespaced attribute names (i.e. `'on:'` in `<div on:click={...} />`).\",\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/no-unknown-namespaces.md\",\n    },\n    hasSuggestions: true,\n    schema: [\n      {\n        type: \"object\",\n        properties: {\n          allowedNamespaces: {\n            description: \"an array of additional namespace names to allow\",\n            type: \"array\",\n            items: {\n              type: \"string\",\n            },\n            default: [],\n            minItems: 1,\n            uniqueItems: true,\n          },\n        },\n        additionalProperties: false,\n      },\n    ],\n    messages: {\n      unknown: `'{{namespace}}:' is not one of Solid's special prefixes for JSX attributes (${knownNamespaces\n        .map((n) => `'${n}:'`)\n        .join(\", \")}).`,\n      style:\n        \"Using the '{{namespace}}:' special prefix is potentially confusing, prefer the '{{namespace}}' prop instead.\",\n      component: \"Namespaced props have no effect on components.\",\n      \"component-suggest\": \"Replace {{namespace}}:{{name}} with {{name}}.\",\n    },\n  },\n  defaultOptions: [],\n  create(context) {\n    const explicitlyAllowedNamespaces = context.options?.[0]?.allowedNamespaces;\n    return {\n      \"JSXAttribute > JSXNamespacedName\": (node: T.JSXNamespacedName) => {\n        const openingElement = node.parent!.parent as T.JSXOpeningElement;\n        if (\n          openingElement.name.type === \"JSXIdentifier\" &&\n          !isDOMElementName(openingElement.name.name)\n        ) {\n          // no namespaces on Solid component elements\n          context.report({\n            node,\n            messageId: \"component\",\n            suggest: [\n              {\n                messageId: \"component-suggest\",\n                data: { namespace: node.namespace.name, name: node.name.name },\n                fix: (fixer) => fixer.replaceText(node, node.name.name),\n              },\n            ],\n          });\n          return;\n        }\n\n        const namespace = node.namespace?.name;\n        if (\n          !(\n            knownNamespaces.includes(namespace) ||\n            otherNamespaces.includes(namespace) ||\n            explicitlyAllowedNamespaces?.includes(namespace)\n          )\n        ) {\n          if (styleNamespaces.includes(namespace)) {\n            context.report({\n              node,\n              messageId: \"style\",\n              data: { namespace },\n            });\n          } else {\n            context.report({\n              node,\n              messageId: \"unknown\",\n              data: { namespace },\n            });\n          }\n        }\n      },\n    };\n  },\n});\n","/**\n * FIXME: remove this comments and import when below issue is fixed.\n * This import is necessary for type generation due to a bug in the TypeScript compiler.\n * See: https://github.com/microsoft/TypeScript/issues/42873\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { TSESLint } from \"@typescript-eslint/utils\";\n\nimport { ESLintUtils, TSESTree as T } from \"@typescript-eslint/utils\";\nimport { jsxHasProp, jsxPropName } from \"../utils\";\n\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\n\ntype MessageIds = \"preferClasslist\";\ntype Options = [{ classnames?: Array<string> }?];\n\nexport default createRule<Options, MessageIds>({\n  meta: {\n    type: \"problem\",\n    docs: {\n      description:\n        \"Enforce using the classlist prop over importing a classnames helper. The classlist prop accepts an object `{ [class: string]: boolean }` just like classnames.\",\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/prefer-classlist.md\",\n    },\n    fixable: \"code\",\n    deprecated: true,\n    schema: [\n      {\n        type: \"object\",\n        properties: {\n          classnames: {\n            type: \"array\",\n            description: \"An array of names to treat as `classnames` functions\",\n            default: [\"cn\", \"clsx\", \"classnames\"],\n            items: {\n              type: \"string\",\n            },\n            minItems: 1,\n            uniqueItems: true,\n          },\n        },\n        additionalProperties: false,\n      },\n    ],\n    messages: {\n      preferClasslist:\n        \"The classlist prop should be used instead of {{ classnames }} to efficiently set classes based on an object.\",\n    },\n  },\n  defaultOptions: [],\n  create(context) {\n    const classnames = context.options[0]?.classnames ?? [\"cn\", \"clsx\", \"classnames\"];\n    return {\n      JSXAttribute(node) {\n        if (\n          [\"class\", \"className\"].indexOf(jsxPropName(node)) === -1 ||\n          jsxHasProp(\n            (node.parent as T.JSXOpeningElement | undefined)?.attributes ?? [],\n            \"classlist\"\n          )\n        ) {\n          return;\n        }\n        if (node.value?.type === \"JSXExpressionContainer\") {\n          const expr = node.value.expression;\n          if (\n            expr.type === \"CallExpression\" &&\n            expr.callee.type === \"Identifier\" &&\n            classnames.indexOf(expr.callee.name) !== -1 &&\n            expr.arguments.length === 1 &&\n            expr.arguments[0].type === \"ObjectExpression\"\n          ) {\n            context.report({\n              node,\n              messageId: \"preferClasslist\",\n              data: {\n                classnames: expr.callee.name,\n              },\n              fix: (fixer) => {\n                const attrRange = node.range;\n                const objectRange = expr.arguments[0].range;\n                return [\n                  fixer.replaceTextRange([attrRange[0], objectRange[0]], \"classlist={\"),\n                  fixer.replaceTextRange([objectRange[1], attrRange[1]], \"}\"),\n                ];\n              },\n            });\n          }\n        }\n      },\n    };\n  },\n});\n","/**\n * FIXME: remove this comments and import when below issue is fixed.\n * This import is necessary for type generation due to a bug in the TypeScript compiler.\n * See: https://github.com/microsoft/TypeScript/issues/42873\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { TSESLint } from \"@typescript-eslint/utils\";\n\nimport { TSESTree as T, ESLintUtils, ASTUtils } from \"@typescript-eslint/utils\";\nimport { isFunctionNode, isJSXElementOrFragment } from \"../utils\";\n\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\nconst { getPropertyName } = ASTUtils;\n\nexport default createRule({\n  meta: {\n    type: \"problem\",\n    docs: {\n      description:\n        \"Enforce using Solid's `<For />` component for mapping an array to JSX elements.\",\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/prefer-for.md\",\n    },\n    fixable: \"code\",\n    schema: [],\n    messages: {\n      preferFor:\n        \"Use Solid's `<For />` component for efficiently rendering lists. Array#map causes DOM elements to be recreated.\",\n      preferForOrIndex:\n        \"Use Solid's `<For />` component or `<Index />` component for rendering lists. Array#map causes DOM elements to be recreated.\",\n    },\n  },\n  defaultOptions: [],\n  create(context) {\n    const reportPreferFor = (node: T.CallExpression) => {\n      const jsxExpressionContainerNode = node.parent as T.JSXExpressionContainer;\n      const arrayNode = (node.callee as T.MemberExpression).object;\n      const mapFnNode = node.arguments[0];\n      context.report({\n        node,\n        messageId: \"preferFor\",\n        fix: (fixer) => {\n          const beforeArray: [number, number] = [\n            jsxExpressionContainerNode.range[0],\n            arrayNode.range[0],\n          ];\n          const betweenArrayAndMapFn: [number, number] = [arrayNode.range[1], mapFnNode.range[0]];\n          const afterMapFn: [number, number] = [\n            mapFnNode.range[1],\n            jsxExpressionContainerNode.range[1],\n          ];\n          // We can insert the <For /> component\n          return [\n            fixer.replaceTextRange(beforeArray, \"<For each={\"),\n            fixer.replaceTextRange(betweenArrayAndMapFn, \"}>{\"),\n            fixer.replaceTextRange(afterMapFn, \"}</For>\"),\n          ];\n        },\n      });\n    };\n\n    return {\n      CallExpression(node) {\n        const callOrChain = node.parent?.type === \"ChainExpression\" ? node.parent : node;\n        if (\n          callOrChain.parent?.type === \"JSXExpressionContainer\" &&\n          isJSXElementOrFragment(callOrChain.parent.parent)\n        ) {\n          // check for Array.prototype.map in JSX\n          if (\n            node.callee.type === \"MemberExpression\" &&\n            getPropertyName(node.callee) === \"map\" &&\n            node.arguments.length === 1 && // passing thisArg to Array.prototype.map is rare, deopt in that case\n            isFunctionNode(node.arguments[0])\n          ) {\n            const mapFnNode = node.arguments[0];\n            if (mapFnNode.params.length === 1 && mapFnNode.params[0].type !== \"RestElement\") {\n              // The map fn doesn't take an index param, so it can't possibly be an index-keyed list. Use <For />.\n              // The returned JSX, if it's coming from React, will have an unnecessary `key` prop to be removed in\n              // the useless-keys rule.\n              reportPreferFor(node);\n            } else {\n              // Too many possible solutions to make a suggestion or fix\n              context.report({\n                node,\n                messageId: \"preferForOrIndex\",\n              });\n            }\n          }\n        }\n      },\n    };\n  },\n});\n","/**\n * FIXME: remove this comments and import when below issue is fixed.\n * This import is necessary for type generation due to a bug in the TypeScript compiler.\n * See: https://github.com/microsoft/TypeScript/issues/42873\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { TSESLint } from \"@typescript-eslint/utils\";\n\nimport { TSESTree as T, ESLintUtils } from \"@typescript-eslint/utils\";\nimport { isJSXElementOrFragment } from \"../utils\";\nimport { getSourceCode } from \"../compat\";\n\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\n\nconst EXPENSIVE_TYPES = [\"JSXElement\", \"JSXFragment\", \"Identifier\"];\n\nexport default createRule({\n  meta: {\n    type: \"problem\",\n    docs: {\n      description:\n        \"Enforce using Solid's `<Show />` component for conditionally showing content. Solid's compiler covers this case, so it's a stylistic rule only.\",\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/prefer-show.md\",\n    },\n    fixable: \"code\",\n    schema: [],\n    messages: {\n      preferShowAnd: \"Use Solid's `<Show />` component for conditionally showing content.\",\n      preferShowTernary:\n        \"Use Solid's `<Show />` component for conditionally showing content with a fallback.\",\n    },\n  },\n  defaultOptions: [],\n  create(context) {\n    const sourceCode = getSourceCode(context);\n    const putIntoJSX = (node: T.Node): string => {\n      const text = sourceCode.getText(node);\n      return isJSXElementOrFragment(node) ? text : `{${text}}`;\n    };\n\n    const logicalExpressionHandler = (node: T.LogicalExpression) => {\n      if (node.operator === \"&&\" && EXPENSIVE_TYPES.includes(node.right.type)) {\n        context.report({\n          node,\n          messageId: \"preferShowAnd\",\n          fix: (fixer) =>\n            fixer.replaceText(\n              node.parent?.type === \"JSXExpressionContainer\" &&\n                isJSXElementOrFragment(node.parent.parent)\n                ? node.parent\n                : node,\n              `<Show when={${sourceCode.getText(node.left)}}>${putIntoJSX(node.right)}</Show>`\n            ),\n        });\n      }\n    };\n    const conditionalExpressionHandler = (node: T.ConditionalExpression) => {\n      if (\n        EXPENSIVE_TYPES.includes(node.consequent.type) ||\n        EXPENSIVE_TYPES.includes(node.alternate.type)\n      ) {\n        context.report({\n          node,\n          messageId: \"preferShowTernary\",\n          fix: (fixer) =>\n            fixer.replaceText(\n              node.parent?.type === \"JSXExpressionContainer\" &&\n                isJSXElementOrFragment(node.parent.parent)\n                ? node.parent\n                : node,\n              `<Show when={${sourceCode.getText(node.test)}} fallback={${sourceCode.getText(\n                node.alternate\n              )}}>${putIntoJSX(node.consequent)}</Show>`\n            ),\n        });\n      }\n    };\n\n    return {\n      JSXExpressionContainer(node) {\n        if (!isJSXElementOrFragment(node.parent)) {\n          return;\n        }\n        if (node.expression.type === \"LogicalExpression\") {\n          logicalExpressionHandler(node.expression);\n        } else if (\n          node.expression.type === \"ArrowFunctionExpression\" &&\n          node.expression.body.type === \"LogicalExpression\"\n        ) {\n          logicalExpressionHandler(node.expression.body);\n        } else if (node.expression.type === \"ConditionalExpression\") {\n          conditionalExpressionHandler(node.expression);\n        } else if (\n          node.expression.type === \"ArrowFunctionExpression\" &&\n          node.expression.body.type === \"ConditionalExpression\"\n        ) {\n          conditionalExpressionHandler(node.expression.body);\n        }\n      },\n    };\n  },\n});\n","/**\n * File overview here, scroll to bottom.\n * @link https://github.com/solidjs-community/eslint-plugin-solid/blob/main/docs/reactivity.md\n */\n\nimport { TSESTree as T, TSESLint, ESLintUtils, ASTUtils } from \"@typescript-eslint/utils\";\nimport { traverse } from \"estraverse\";\nimport {\n  findParent,\n  findInScope,\n  isPropsByName,\n  FunctionNode,\n  isFunctionNode,\n  ProgramOrFunctionNode,\n  isProgramOrFunctionNode,\n  trackImports,\n  isDOMElementName,\n  ignoreTransparentWrappers,\n  getFunctionName,\n  isJSXElementOrFragment,\n  trace,\n} from \"../utils\";\nimport { findVariable, CompatContext, getSourceCode } from \"../compat\";\n\nconst { getFunctionHeadLocation } = ASTUtils;\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\n\ntype Variable = TSESLint.Scope.Variable;\ntype Reference = TSESLint.Scope.Reference;\n\ninterface ReactiveVariable {\n  /**\n   * The reactive variable references we're concerned with (i.e. not init).\n   * References are removed after they are analyzed.\n   */\n  references: Array<Reference>;\n  /**\n   * The function node in which the reactive variable was declared, or for a\n   * derived signal (function), the deepest function node that declares a\n   * referenced signal.\n   */\n  declarationScope: ProgramOrFunctionNode;\n  /**\n   * The reactive variable. Not used directly, only needed for identification\n   * in pushUniqueDerivedSignal.\n   */\n  variable: Variable;\n}\n\ninterface TrackedScope {\n  /**\n   * The root node, usually a function or JSX expression container, to allow\n   * reactive variables under.\n   */\n  node: T.Node;\n  /**\n   * The reactive variable should be one of these types:\n   * - \"function\": synchronous function or signal variable\n   * - \"called-function\": synchronous or asynchronous function like a timer or\n   *   event handler that isn't really a tracked scope but allows reactivity\n   * - \"expression\": some value containing reactivity somewhere\n   */\n  expect: \"function\" | \"called-function\" | \"expression\";\n}\n\nclass ScopeStackItem {\n  /** the node for the current scope, or program if global scope */\n  node: ProgramOrFunctionNode;\n  /**\n   * nodes whose descendants in the current scope are allowed to be reactive.\n   * JSXExpressionContainers can be any expression containing reactivity, while\n   * function nodes/identifiers are typically arguments to solid-js primitives\n   * and should match a tracked scope exactly.\n   */\n  trackedScopes: Array<TrackedScope> = [];\n  /** nameless functions with reactivity, should exactly match a tracked scope */\n  unnamedDerivedSignals = new Set<FunctionNode>();\n  /** switched to true by time of :exit if JSX is detected in the current scope */\n  hasJSX = false;\n\n  constructor(node: ProgramOrFunctionNode) {\n    this.node = node;\n  }\n}\n\nclass ScopeStack extends Array<ScopeStackItem> {\n  currentScope = () => this[this.length - 1];\n  parentScope = () => this[this.length - 2];\n\n  /** Add references to a signal, memo, derived signal, etc. */\n  pushSignal(\n    variable: Variable,\n    declarationScope: ProgramOrFunctionNode = this.currentScope().node\n  ) {\n    this.signals.push({\n      references: variable.references.filter((reference) => !reference.init),\n      variable,\n      declarationScope,\n    });\n  }\n\n  /**\n   * Add references to a signal, merging with existing references if the\n   * variable is the same. Derived signals are special; they don't use the\n   * declaration scope of the function, but rather the minimum declaration scope\n   * of any signals they contain.\n   */\n  pushUniqueSignal(variable: Variable, declarationScope: ProgramOrFunctionNode) {\n    const foundSignal = this.signals.find((s) => s.variable === variable);\n    if (!foundSignal) {\n      this.pushSignal(variable, declarationScope);\n    } else {\n      foundSignal.declarationScope = this.findDeepestDeclarationScope(\n        foundSignal.declarationScope,\n        declarationScope\n      );\n    }\n  }\n\n  /** Add references to a props or store. */\n  pushProps(\n    variable: Variable,\n    declarationScope: ProgramOrFunctionNode = this.currentScope().node\n  ) {\n    this.props.push({\n      references: variable.references.filter((reference) => !reference.init),\n      variable,\n      declarationScope,\n    });\n  }\n\n  /** Function callbacks that run synchronously and don't create a new scope. */\n  syncCallbacks = new Set<FunctionNode>();\n\n  /**\n   * Iterate through and remove the signal references in the current scope.\n   * That way, the next Scope up can safely check for references in its scope.\n   */\n  *consumeSignalReferencesInScope() {\n    yield* this.consumeReferencesInScope(this.signals);\n    this.signals = this.signals.filter((variable) => variable.references.length !== 0);\n  }\n\n  /** Iterate through and remove the props references in the current scope. */\n  *consumePropsReferencesInScope() {\n    yield* this.consumeReferencesInScope(this.props);\n    this.props = this.props.filter((variable) => variable.references.length !== 0);\n  }\n\n  private *consumeReferencesInScope(\n    variables: Array<ReactiveVariable>\n  ): Iterable<{ reference: Reference; declarationScope: ProgramOrFunctionNode }> {\n    for (const variable of variables) {\n      const { references } = variable;\n      const inScope: Array<Reference> = [],\n        notInScope: Array<Reference> = [];\n      references.forEach((reference) => {\n        if (this.isReferenceInCurrentScope(reference)) {\n          inScope.push(reference);\n        } else {\n          notInScope.push(reference);\n        }\n      });\n      yield* inScope.map((reference) => ({\n        reference,\n        declarationScope: variable.declarationScope,\n      }));\n      // I don't think this is needed! Just a perf optimization\n      variable.references = notInScope;\n    }\n  }\n\n  /** Returns the function node deepest in the tree. Assumes a === b, a is inside b, or b is inside a. */\n  private findDeepestDeclarationScope = (\n    a: ProgramOrFunctionNode,\n    b: ProgramOrFunctionNode\n  ): ProgramOrFunctionNode => {\n    if (a === b) return a;\n    for (let i = this.length - 1; i >= 0; i -= 1) {\n      const { node } = this[i];\n      if (a === node || b === node) {\n        return node;\n      }\n    }\n    throw new Error(\"This should never happen\");\n  };\n\n  /**\n   * Returns true if the reference is in the current scope, handling sync\n   * callbacks. Must be called on the :exit pass only.\n   */\n  private isReferenceInCurrentScope(reference: Reference) {\n    let parentFunction = findParent(reference.identifier, isProgramOrFunctionNode);\n    while (isFunctionNode(parentFunction) && this.syncCallbacks.has(parentFunction)) {\n      parentFunction = findParent(parentFunction, isProgramOrFunctionNode);\n    }\n    return parentFunction === this.currentScope().node;\n  }\n\n  /** variable references to be treated as signals, memos, derived signals, etc. */\n  private signals: Array<ReactiveVariable> = [];\n  /** variables references to be treated as props (or stores) */\n  private props: Array<ReactiveVariable> = [];\n}\n\nconst getNthDestructuredVar = (id: T.Node, n: number, context: CompatContext): Variable | null => {\n  if (id?.type === \"ArrayPattern\") {\n    const el = id.elements[n];\n    if (el?.type === \"Identifier\") {\n      return findVariable(context, el);\n    }\n  }\n  return null;\n};\n\nconst getReturnedVar = (id: T.Node, context: CompatContext): Variable | null => {\n  if (id.type === \"Identifier\") {\n    return findVariable(context, id);\n  }\n  return null;\n};\n\ntype MessageIds =\n  | \"noWrite\"\n  | \"untrackedReactive\"\n  | \"expectedFunctionGotExpression\"\n  | \"badSignal\"\n  | \"badUnnamedDerivedSignal\"\n  | \"shouldDestructure\"\n  | \"shouldAssign\"\n  | \"noAsyncTrackedScope\";\ntype Options = [{ customReactiveFunctions: string[] }];\n\nexport default createRule<Options, MessageIds>({\n  meta: {\n    type: \"problem\",\n    docs: {\n      description:\n        \"Enforce that reactivity (props, signals, memos, etc.) is properly used, so changes in those values will be tracked and update the view as expected.\",\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/reactivity.md\",\n    },\n    schema: [\n      {\n        type: \"object\",\n        properties: {\n          customReactiveFunctions: {\n            description:\n              \"List of function names to consider as reactive functions (allow signals to be safely passed as arguments). In addition, any create* or use* functions are automatically included.\",\n            type: \"array\",\n            items: {\n              type: \"string\",\n            },\n            default: [],\n          },\n        },\n        additionalProperties: false,\n      },\n    ],\n    messages: {\n      noWrite: \"The reactive variable '{{name}}' should not be reassigned or altered directly.\",\n      untrackedReactive:\n        \"The reactive variable '{{name}}' should be used within JSX, a tracked scope (like createEffect), or inside an event handler function, or else changes will be ignored.\",\n      expectedFunctionGotExpression:\n        \"The reactive variable '{{name}}' should be wrapped in a function for reactivity. This includes event handler bindings on native elements, which are not reactive like other JSX props.\",\n      badSignal:\n        \"The reactive variable '{{name}}' should be called as a function when used in {{where}}.\",\n      badUnnamedDerivedSignal:\n        \"This function should be passed to a tracked scope (like createEffect) or an event handler because it contains reactivity, or else changes will be ignored.\",\n      shouldDestructure:\n        \"For proper analysis, array destructuring should be used to capture the {{nth}}result of this function call.\",\n      shouldAssign:\n        \"For proper analysis, a variable should be used to capture the result of this function call.\",\n      noAsyncTrackedScope:\n        \"This tracked scope should not be async. Solid's reactivity only tracks synchronously.\",\n    },\n  },\n  defaultOptions: [\n    {\n      customReactiveFunctions: [],\n    },\n  ],\n  create(context, [options]) {\n    const warnShouldDestructure = (node: T.Node, nth?: string) =>\n      context.report({\n        node,\n        messageId: \"shouldDestructure\",\n        data: nth ? { nth: nth + \" \" } : undefined,\n      });\n    const warnShouldAssign = (node: T.Node) => context.report({ node, messageId: \"shouldAssign\" });\n\n    const sourceCode = getSourceCode(context);\n\n    /** Represents the lexical function stack and relevant information for each function */\n    const scopeStack = new ScopeStack();\n    const { currentScope, parentScope } = scopeStack;\n\n    /** Tracks imports from 'solid-js', handling aliases. */\n    const { matchImport, handleImportDeclaration } = trackImports();\n\n    /** Workaround for #61 */\n    const markPropsOnCondition = (node: FunctionNode, cb: (props: T.Identifier) => boolean) => {\n      if (\n        node.params.length === 1 &&\n        node.params[0].type === \"Identifier\" &&\n        node.parent?.type !== \"JSXExpressionContainer\" && // \"render props\" aren't components\n        node.parent?.type !== \"TemplateLiteral\" && // inline functions in tagged template literals aren't components\n        cb(node.params[0])\n      ) {\n        // This function is a component, consider its parameter a props\n        const propsParam = findVariable(context, node.params[0]);\n        if (propsParam) {\n          scopeStack.pushProps(propsParam, node);\n        }\n      }\n    };\n\n    /** Populates the function stack. */\n    const onFunctionEnter = (node: ProgramOrFunctionNode) => {\n      if (isFunctionNode(node)) {\n        if (scopeStack.syncCallbacks.has(node)) {\n          // Ignore sync callbacks like Array#forEach and certain Solid primitives\n          return;\n        }\n        markPropsOnCondition(node, (props) => isPropsByName(props.name));\n      }\n      scopeStack.push(new ScopeStackItem(node));\n    };\n\n    /** Returns whether a node falls under a tracked scope in the current function scope */\n    const matchTrackedScope = (trackedScope: TrackedScope, node: T.Node): boolean => {\n      switch (trackedScope.expect) {\n        case \"function\":\n        case \"called-function\":\n          return node === trackedScope.node;\n        case \"expression\":\n          return Boolean(\n            findInScope(node, currentScope().node, (node) => node === trackedScope.node)\n          );\n      }\n    };\n\n    /** Inspects a specific reference of a reactive variable for correct handling. */\n    const handleTrackedScopes = (\n      identifier: T.Identifier,\n      declarationScope: ProgramOrFunctionNode\n    ) => {\n      const currentScopeNode = currentScope().node;\n      // Check if the call falls outside any tracked scopes in the current scope\n      if (\n        !currentScope().trackedScopes.find((trackedScope) =>\n          matchTrackedScope(trackedScope, identifier)\n        )\n      ) {\n        const matchedExpression = currentScope().trackedScopes.find((trackedScope) =>\n          matchTrackedScope({ ...trackedScope, expect: \"expression\" }, identifier)\n        );\n        if (declarationScope === currentScopeNode) {\n          // If the reactivity is not contained in a tracked scope, and any of\n          // the reactive variables were declared in the current scope, then we\n          // report them. When the reference is to an object in a\n          // MemberExpression (props/store) or a function call (signal), report\n          // that, otherwise the identifier.\n          let parentMemberExpression: T.MemberExpression | null = null;\n          if (identifier.parent?.type === \"MemberExpression\") {\n            parentMemberExpression = identifier.parent;\n            while (parentMemberExpression!.parent?.type === \"MemberExpression\") {\n              parentMemberExpression = parentMemberExpression!.parent;\n            }\n          }\n          const parentCallExpression =\n            identifier.parent?.type === \"CallExpression\" ? identifier.parent : null;\n          context.report({\n            node: parentMemberExpression ?? parentCallExpression ?? identifier,\n            messageId: matchedExpression ? \"expectedFunctionGotExpression\" : \"untrackedReactive\",\n            data: {\n              name: parentMemberExpression\n                ? sourceCode.getText(parentMemberExpression)\n                : identifier.name,\n            },\n          });\n        } else {\n          // If all of the reactive variables were declared above the current\n          // function scope, then the entire function becomes reactive with the\n          // deepest declaration scope of the reactive variables it contains.\n          // Let the next onFunctionExit up handle it.\n          if (!parentScope() || !isFunctionNode(currentScopeNode)) {\n            throw new Error(\"this shouldn't happen!\");\n          }\n\n          // If the current function doesn't have an associated variable, that's\n          // fine, it's being used inline (i.e. anonymous arrow function). For\n          // this to be okay, the arrow function has to be the same node as one\n          // of the tracked scopes, as we can't easily find references.\n          const pushUnnamedDerivedSignal = () =>\n            (parentScope().unnamedDerivedSignals ??= new Set()).add(currentScopeNode);\n\n          if (currentScopeNode.type === \"FunctionDeclaration\") {\n            // get variable representing function, function node only defines one variable\n            const functionVariable: Variable | undefined =\n              sourceCode.scopeManager?.getDeclaredVariables(currentScopeNode)?.[0];\n            if (functionVariable) {\n              scopeStack.pushUniqueSignal(\n                functionVariable,\n                declarationScope // use declaration scope of a signal contained in this function\n              );\n            } else {\n              pushUnnamedDerivedSignal();\n            }\n          } else if (currentScopeNode.parent?.type === \"VariableDeclarator\") {\n            const declarator = currentScopeNode.parent;\n            // for nameless or arrow function expressions, use the declared variable it's assigned to\n            const functionVariable = sourceCode.scopeManager?.getDeclaredVariables(declarator)?.[0];\n            if (functionVariable) {\n              // use declaration scope of a signal contained in this scope, not the function itself\n              scopeStack.pushUniqueSignal(functionVariable, declarationScope);\n            } else {\n              pushUnnamedDerivedSignal();\n            }\n          } else if (currentScopeNode.parent?.type === \"Property\") {\n            // todo make this a unique props or something--for now, just ignore (unsafe)\n          } else {\n            pushUnnamedDerivedSignal();\n          }\n        }\n      }\n    };\n\n    /** Performs all analysis and reporting. */\n    const onFunctionExit = (currentScopeNode: ProgramOrFunctionNode) => {\n      // If this function is a component, add its props as a reactive variable\n      if (isFunctionNode(currentScopeNode)) {\n        markPropsOnCondition(currentScopeNode, (props) => {\n          if (\n            !isPropsByName(props.name) && // already added in markPropsOnEnter\n            currentScope().hasJSX\n          ) {\n            const functionName = getFunctionName(currentScopeNode);\n            // begins with lowercase === not component\n            if (functionName && !/^[a-z]/.test(functionName)) return true;\n          }\n          return false;\n        });\n      }\n\n      // Ignore sync callbacks like Array#forEach and certain Solid primitives.\n      // In this case only, currentScopeNode !== currentScope().node, but we're\n      // returning early so it doesn't matter.\n      if (isFunctionNode(currentScopeNode) && scopeStack.syncCallbacks.has(currentScopeNode)) {\n        return;\n      }\n\n      // Iterate through all usages of (derived) signals in the current scope\n      for (const { reference, declarationScope } of scopeStack.consumeSignalReferencesInScope()) {\n        const identifier = reference.identifier;\n        if (reference.isWrite()) {\n          // don't allow reassigning signals\n          context.report({\n            node: identifier,\n            messageId: \"noWrite\",\n            data: {\n              name: identifier.name,\n            },\n          });\n        } else if (identifier.type === \"Identifier\") {\n          const reportBadSignal = (where: string) =>\n            context.report({\n              node: identifier,\n              messageId: \"badSignal\",\n              data: { name: identifier.name, where },\n            });\n          if (\n            // This allows both calling a signal and calling a function with a signal.\n            identifier.parent?.type === \"CallExpression\" ||\n            // Also allow the case where we pass an array of signals, such as in a custom hook\n            (identifier.parent?.type === \"ArrayExpression\" &&\n              identifier.parent.parent?.type === \"CallExpression\")\n          ) {\n            // This signal is getting called properly, analyze it.\n            handleTrackedScopes(identifier, declarationScope);\n          } else if (identifier.parent?.type === \"TemplateLiteral\") {\n            reportBadSignal(\"template literals\");\n          } else if (\n            identifier.parent?.type === \"BinaryExpression\" &&\n            [\n              \"<\",\n              \"<=\",\n              \">\",\n              \">=\",\n              \"<<\",\n              \">>\",\n              \">>>\",\n              \"+\",\n              \"-\",\n              \"*\",\n              \"/\",\n              \"%\",\n              \"**\",\n              \"|\",\n              \"^\",\n              \"&\",\n              \"in\",\n            ].includes(identifier.parent.operator)\n          ) {\n            // We're in an arithmetic/comparison expression where using an uncalled signal wouldn't make sense\n            reportBadSignal(\"arithmetic or comparisons\");\n          } else if (\n            identifier.parent?.type === \"UnaryExpression\" &&\n            [\"-\", \"+\", \"~\"].includes(identifier.parent.operator)\n          ) {\n            // We're in a unary expression where using an uncalled signal wouldn't make sense\n            reportBadSignal(\"unary expressions\");\n          } else if (\n            identifier.parent?.type === \"MemberExpression\" &&\n            identifier.parent.computed &&\n            identifier.parent.property === identifier\n          ) {\n            // We're using an uncalled signal to index an object or array, which doesn't make sense\n            reportBadSignal(\"property accesses\");\n          } else if (\n            identifier.parent?.type === \"JSXExpressionContainer\" &&\n            !currentScope().trackedScopes.find(\n              (trackedScope) =>\n                trackedScope.node === identifier &&\n                (trackedScope.expect === \"function\" || trackedScope.expect === \"called-function\")\n            )\n          ) {\n            // If the signal is in a JSXExpressionContainer that's also marked as a \"function\" or \"called-function\" tracked scope,\n            // let it be.\n            const elementOrAttribute = identifier.parent.parent;\n            if (\n              // The signal is not being called and is being used as a props.children, where calling\n              // the signal was the likely intent.\n              isJSXElementOrFragment(elementOrAttribute) ||\n              // We can't say for sure about user components, but we know for a fact that a signal\n              // should not be passed to a non-event handler DOM element attribute without calling it.\n              (elementOrAttribute?.type === \"JSXAttribute\" &&\n                elementOrAttribute.parent?.type === \"JSXOpeningElement\" &&\n                elementOrAttribute.parent.name.type === \"JSXIdentifier\" &&\n                isDOMElementName(elementOrAttribute.parent.name.name))\n            ) {\n              reportBadSignal(\"JSX\");\n            }\n          }\n        }\n        // The signal is being read outside of a CallExpression. Since\n        // there's a lot of possibilities here and they're generally fine,\n        // do nothing.\n      }\n\n      // Do a similar thing with all usages of props in the current function\n      for (const { reference, declarationScope } of scopeStack.consumePropsReferencesInScope()) {\n        const identifier = reference.identifier;\n        if (reference.isWrite()) {\n          // don't allow reassigning props or stores\n          context.report({\n            node: identifier,\n            messageId: \"noWrite\",\n            data: {\n              name: identifier.name,\n            },\n          });\n        } else if (\n          identifier.parent?.type === \"MemberExpression\" &&\n          identifier.parent.object === identifier\n        ) {\n          const { parent } = identifier;\n          if (parent.parent?.type === \"AssignmentExpression\" && parent.parent.left === parent) {\n            // don't allow writing to props or stores directly\n            context.report({\n              node: identifier,\n              messageId: \"noWrite\",\n              data: {\n                name: identifier.name,\n              },\n            });\n          } else if (\n            parent.property.type === \"Identifier\" &&\n            /^(?:initial|default|static[A-Z])/.test(parent.property.name)\n          ) {\n            // We're using a prop with a name that starts with `initial` or\n            // `default`, like `props.initialCount`. We'll refrain from warning\n            // about untracked usages of these props, because the user has shown\n            // that they understand the consequences of using a reactive\n            // variable to initialize something else. Do nothing.\n          } else {\n            // The props are the object in a property read access, which\n            // should be under a tracked scope.\n            handleTrackedScopes(identifier, declarationScope);\n          }\n        } else if (\n          identifier.parent?.type === \"AssignmentExpression\" ||\n          identifier.parent?.type === \"VariableDeclarator\"\n        ) {\n          // There's no reason to allow `... = props`, it's usually destructuring, which breaks reactivity.\n          context.report({\n            node: identifier,\n            messageId: \"untrackedReactive\",\n            data: { name: identifier.name },\n          });\n        }\n        // The props are being read, but not in a MemberExpression. Since\n        // there's a lot of possibilities here and they're generally fine,\n        // do nothing.\n      }\n\n      // If there are any unnamed derived signals, they must match a tracked\n      // scope. Usually anonymous arrow function args to createEffect,\n      // createMemo, etc.\n      const { unnamedDerivedSignals } = currentScope();\n      if (unnamedDerivedSignals) {\n        for (const node of unnamedDerivedSignals) {\n          if (\n            !currentScope().trackedScopes.find((trackedScope) =>\n              matchTrackedScope(trackedScope, node)\n            )\n          ) {\n            context.report({\n              loc: getFunctionHeadLocation(node, sourceCode),\n              messageId: \"badUnnamedDerivedSignal\",\n            });\n          }\n        }\n      }\n\n      // Pop on exit\n      scopeStack.pop();\n    };\n\n    /*\n     * Sync array functions (forEach, map, reduce, reduceRight, flatMap),\n     * store update fn params (ex. setState(\"todos\", (t) => [...t.slice(0, i()),\n     * ...t.slice(i() + 1)])), batch, onCleanup, and onError fn params, and\n     * maybe a few others don't actually create a new scope. That is, any\n     * signal/prop accesses in these functions act as if they happen in the\n     * enclosing function. Note that this means whether or not the enclosing\n     * function is a tracking scope applies to the fn param as well.\n     *\n     * Every time a sync callback is detected, we put that function node into a\n     * syncCallbacks Set<FunctionNode>. The detections must happen on the entry pass\n     * and when the function node has not yet been traversed. In onFunctionEnter, if\n     * the function node is in syncCallbacks, we don't push it onto the\n     * scopeStack. In onFunctionExit, if the function node is in syncCallbacks,\n     * we don't pop scopeStack.\n     */\n    const checkForSyncCallbacks = (node: T.CallExpression) => {\n      if (\n        node.arguments.length === 1 &&\n        isFunctionNode(node.arguments[0]) &&\n        !node.arguments[0].async\n      ) {\n        if (\n          node.callee.type === \"Identifier\" &&\n          matchImport([\"batch\", \"produce\"], node.callee.name)\n        ) {\n          // These Solid APIs take callbacks that run in the current scope\n          scopeStack.syncCallbacks.add(node.arguments[0]);\n        } else if (\n          node.callee.type === \"MemberExpression\" &&\n          !node.callee.computed &&\n          node.callee.object.type !== \"ObjectExpression\" &&\n          /^(?:forEach|map|flatMap|reduce|reduceRight|find|findIndex|filter|every|some)$/.test(\n            node.callee.property.name\n          )\n        ) {\n          // These common array methods (or likely array methods) take synchronous callbacks\n          scopeStack.syncCallbacks.add(node.arguments[0]);\n        }\n      }\n      if (node.callee.type === \"Identifier\") {\n        if (\n          matchImport([\"createSignal\", \"createStore\"], node.callee.name) &&\n          node.parent?.type === \"VariableDeclarator\"\n        ) {\n          // Allow using reactive variables in state setter if the current scope is tracked.\n          // ex.  const [state, setState] = createStore({ ... });\n          //      setState(() => ({ preferredName: state.firstName, lastName: \"Milner\" }));\n          const setter = getNthDestructuredVar(node.parent.id, 1, context);\n          if (setter) {\n            for (const reference of setter.references) {\n              const { identifier } = reference;\n              if (\n                !reference.init &&\n                reference.isRead() &&\n                identifier.parent?.type === \"CallExpression\"\n              ) {\n                for (const arg of identifier.parent.arguments) {\n                  if (isFunctionNode(arg) && !arg.async) {\n                    scopeStack.syncCallbacks.add(arg);\n                  }\n                }\n              }\n            }\n          }\n        } else if (matchImport([\"mapArray\", \"indexArray\"], node.callee.name)) {\n          const arg1 = node.arguments[1];\n          if (isFunctionNode(arg1)) {\n            scopeStack.syncCallbacks.add(arg1);\n          }\n        }\n      }\n      // Handle IIFEs\n      if (isFunctionNode(node.callee)) {\n        scopeStack.syncCallbacks.add(node.callee);\n      }\n    };\n\n    /** Checks VariableDeclarators, AssignmentExpressions, and CallExpressions for reactivity. */\n    const checkForReactiveAssignment = (\n      id: T.BindingName | T.AssignmentExpression[\"left\"] | null,\n      init: T.Node\n    ) => {\n      init = ignoreTransparentWrappers(init);\n\n      // Mark return values of certain functions as reactive\n      if (init.type === \"CallExpression\" && init.callee.type === \"Identifier\") {\n        const { callee } = init;\n        if (matchImport([\"createSignal\", \"useTransition\"], callee.name)) {\n          const signal = id && getNthDestructuredVar(id, 0, context);\n          if (signal) {\n            scopeStack.pushSignal(signal, currentScope().node);\n          } else {\n            warnShouldDestructure(id ?? init, \"first\");\n          }\n        } else if (matchImport([\"createMemo\", \"createSelector\"], callee.name)) {\n          const memo = id && getReturnedVar(id, context);\n          // memos act like signals\n          if (memo) {\n            scopeStack.pushSignal(memo, currentScope().node);\n          } else {\n            warnShouldAssign(id ?? init);\n          }\n        } else if (matchImport(\"createStore\", callee.name)) {\n          const store = id && getNthDestructuredVar(id, 0, context);\n          // stores act like props\n          if (store) {\n            scopeStack.pushProps(store, currentScope().node);\n          } else {\n            warnShouldDestructure(id ?? init, \"first\");\n          }\n        } else if (matchImport(\"mergeProps\", callee.name)) {\n          const merged = id && getReturnedVar(id, context);\n          if (merged) {\n            scopeStack.pushProps(merged, currentScope().node);\n          } else {\n            warnShouldAssign(id ?? init);\n          }\n        } else if (matchImport(\"splitProps\", callee.name)) {\n          // splitProps can return an unbounded array of props variables, though it's most often two\n          if (id?.type === \"ArrayPattern\") {\n            const vars = id.elements\n              .map((_, i) => getNthDestructuredVar(id, i, context))\n              .filter(Boolean) as Array<Variable>;\n            if (vars.length === 0) {\n              warnShouldDestructure(id);\n            } else {\n              vars.forEach((variable) => {\n                scopeStack.pushProps(variable, currentScope().node);\n              });\n            }\n          } else {\n            // if it's returned as an array, treat that as a props object\n            const vars = id && getReturnedVar(id, context);\n            if (vars) {\n              scopeStack.pushProps(vars, currentScope().node);\n            }\n          }\n        } else if (matchImport(\"createResource\", callee.name)) {\n          // createResource return value has reactive .loading and .error\n          const resourceReturn = id && getNthDestructuredVar(id, 0, context);\n          if (resourceReturn) {\n            scopeStack.pushProps(resourceReturn, currentScope().node);\n          }\n        } else if (matchImport(\"createMutable\", callee.name)) {\n          const mutable = id && getReturnedVar(id, context);\n          if (mutable) {\n            scopeStack.pushProps(mutable, currentScope().node);\n          }\n        } else if (matchImport(\"mapArray\", callee.name)) {\n          const arg1 = init.arguments[1];\n          if (\n            isFunctionNode(arg1) &&\n            arg1.params.length >= 2 &&\n            arg1.params[1].type === \"Identifier\"\n          ) {\n            const indexSignal = findVariable(context, arg1.params[1]);\n            if (indexSignal) {\n              scopeStack.pushSignal(indexSignal);\n            }\n          }\n        } else if (matchImport(\"indexArray\", callee.name)) {\n          const arg1 = init.arguments[1];\n          if (\n            isFunctionNode(arg1) &&\n            arg1.params.length >= 1 &&\n            arg1.params[0].type === \"Identifier\"\n          ) {\n            const valueSignal = findVariable(context, arg1.params[0]);\n            if (valueSignal) {\n              scopeStack.pushSignal(valueSignal);\n            }\n          }\n        }\n      }\n    };\n\n    const checkForTrackedScopes = (\n      node:\n        | T.JSXExpressionContainer\n        | T.JSXSpreadAttribute\n        | T.CallExpression\n        | T.VariableDeclarator\n        | T.AssignmentExpression\n        | T.TaggedTemplateExpression\n        | T.NewExpression\n    ) => {\n      const pushTrackedScope = (node: T.Node, expect: TrackedScope[\"expect\"]) => {\n        currentScope().trackedScopes.push({ node, expect });\n        if (expect !== \"called-function\" && isFunctionNode(node) && node.async) {\n          // From the docs: \"[Solid's] approach only tracks synchronously. If you\n          // have a setTimeout or use an async function in your Effect the code\n          // that executes async after the fact won't be tracked.\"\n          context.report({\n            node,\n            messageId: \"noAsyncTrackedScope\",\n          });\n        }\n      };\n      // given some expression, mark any functions within it as tracking scopes, and do not traverse\n      // those functions\n      const permissivelyTrackNode = (node: T.Node) => {\n        traverse(node as any, {\n          enter(cn) {\n            const childNode = cn as T.Node;\n            const traced = trace(childNode, context);\n            // when referencing a function or something that could be a derived signal, track it\n            if (\n              isFunctionNode(traced) ||\n              (traced.type === \"Identifier\" &&\n                traced.parent.type !== \"MemberExpression\" &&\n                !(traced.parent.type === \"CallExpression\" && traced.parent.callee === traced))\n            ) {\n              pushTrackedScope(childNode, \"called-function\");\n              this.skip(); // poor-man's `findInScope`: don't enter child scopes\n            }\n          },\n          fallback: \"iteration\", // Don't crash when encounter unknown node.\n        });\n      };\n\n      if (node.type === \"JSXExpressionContainer\") {\n        if (\n          node.parent?.type === \"JSXAttribute\" &&\n          sourceCode.getText(node.parent.name).startsWith(\"on\") &&\n          node.parent.parent?.type === \"JSXOpeningElement\" &&\n          node.parent.parent.name.type === \"JSXIdentifier\" &&\n          isDOMElementName(node.parent.parent.name.name)\n        ) {\n          // Expect a function if the attribute is like onClick={}, onclick={}, on:click={}, or\n          // custom events such as on-click={}.\n          // From the docs:\n          // Events are never rebound and the bindings are not reactive, as it is expensive to\n          // attach and detach listeners. Since event handlers are called like any other function\n          // each time an event fires, there is no need for reactivity; simply shortcut your handler\n          // if desired.\n          // What this means here is we actually do consider an event handler a tracked scope\n          // expecting a function, i.e. it's okay to use changing props/signals in the body of the\n          // function, even though the changes don't affect when the handler will run. This is what\n          // \"called-function\" represents—not quite a tracked scope, but a place where it's okay to\n          // read reactive values.\n          pushTrackedScope(node.expression, \"called-function\");\n        } else if (\n          node.parent?.type === \"JSXAttribute\" &&\n          node.parent.name.type === \"JSXNamespacedName\" &&\n          node.parent.name.namespace.name === \"use\" &&\n          isFunctionNode(node.expression)\n        ) {\n          // With a `use:` hook, assume that a function passed is a called function.\n          pushTrackedScope(node.expression, \"called-function\");\n        } else if (\n          node.parent?.type === \"JSXAttribute\" &&\n          node.parent.name.name === \"value\" &&\n          node.parent.parent?.type === \"JSXOpeningElement\" &&\n          ((node.parent.parent.name.type === \"JSXIdentifier\" &&\n            node.parent.parent.name.name.endsWith(\"Provider\")) ||\n            (node.parent.parent.name.type === \"JSXMemberExpression\" &&\n              node.parent.parent.name.property.name === \"Provider\"))\n        ) {\n          // From the docs: \"The value passed to provider is passed to useContext as is. That means\n          // wrapping as a reactive expression will not work. You should pass in Signals and Stores\n          // directly instead of accessing them in the JSX.\"\n          // For `<SomeContext.Provider value={}>` or `<SomeProvider value={}>`, do nothing, the\n          // rule will warn later.\n          // TODO: add some kind of \"anti- tracked scope\" that still warns but enhances the error\n          // message if matched.\n        } else if (\n          node.parent?.type === \"JSXAttribute\" &&\n          node.parent.name?.type === \"JSXIdentifier\" &&\n          /^static[A-Z]/.test(node.parent.name.name) &&\n          node.parent.parent?.type === \"JSXOpeningElement\" &&\n          node.parent.parent.name.type === \"JSXIdentifier\" &&\n          !isDOMElementName(node.parent.parent.name.name)\n        ) {\n          // A caller is passing a value to a prop prefixed with `static` in a component, i.e.\n          // `<Box staticName={...} />`. Since we're considering these props as static in the component\n          // we shouldn't allow passing reactive values to them, as this isn't just ignoring reactivity\n          // like initial*/default*; this is disabling it altogether as a convention. Do nothing.\n        } else if (\n          node.parent?.type === \"JSXAttribute\" &&\n          node.parent.name.name === \"ref\" &&\n          isFunctionNode(node.expression)\n        ) {\n          // Callback/function refs are called when an element is created but before it is connected\n          // to the DOM. This is semantically a \"called function\", so it's fine to read reactive\n          // variables here.\n          pushTrackedScope(node.expression, \"called-function\");\n        } else if (isJSXElementOrFragment(node.parent) && isFunctionNode(node.expression)) {\n          pushTrackedScope(node.expression, \"function\"); // functions inline in JSX containers will be tracked\n        } else {\n          pushTrackedScope(node.expression, \"expression\");\n        }\n      } else if (node.type === \"JSXSpreadAttribute\") {\n        // allow <div {...props.nestedProps} />; {...props} is already ignored\n        pushTrackedScope(node.argument, \"expression\");\n      } else if (node.type === \"NewExpression\") {\n        const {\n          callee,\n          arguments: { 0: arg0 },\n        } = node;\n        if (\n          callee.type === \"Identifier\" &&\n          arg0 &&\n          // Observers from Standard Web APIs\n          [\n            \"IntersectionObserver\",\n            \"MutationObserver\",\n            \"PerformanceObserver\",\n            \"ReportingObserver\",\n            \"ResizeObserver\",\n          ].includes(callee.name)\n        ) {\n          // Observers callbacks are NOT tracked scopes. However, they\n          // don't need to react to updates to reactive variables; it's okay\n          // to poll the current value. Consider them called-function tracked\n          // scopes for our purposes.\n          pushTrackedScope(arg0, \"called-function\");\n        }\n      } else if (node.type === \"CallExpression\") {\n        if (node.callee.type === \"Identifier\") {\n          const {\n            callee,\n            arguments: { 0: arg0, 1: arg1 },\n          } = node;\n          if (\n            matchImport(\n              [\n                \"createMemo\",\n                \"children\",\n                \"createEffect\",\n                \"createRenderEffect\",\n                \"createDeferred\",\n                \"createComputed\",\n                \"createSelector\",\n                \"untrack\",\n                \"mapArray\",\n                \"indexArray\",\n                \"observable\",\n              ],\n              callee.name\n            ) ||\n            (matchImport(\"createResource\", callee.name) && node.arguments.length >= 2)\n          ) {\n            // createEffect, createMemo, etc. fn arg, and createResource optional\n            // `source` first argument may be a signal\n            pushTrackedScope(arg0, \"function\");\n          } else if (\n            matchImport([\"onMount\", \"onCleanup\", \"onError\"], callee.name) ||\n            [\n              // Timers\n              \"setInterval\",\n              \"setTimeout\",\n              \"setImmediate\",\n              \"requestAnimationFrame\",\n              \"requestIdleCallback\",\n            ].includes(callee.name)\n          ) {\n            // on* and timers are NOT tracked scopes. However, they\n            // don't need to react to updates to reactive variables; it's okay\n            // to poll the current value. Consider them called-function tracked\n            // scopes for our purposes.\n            pushTrackedScope(arg0, \"called-function\");\n          } else if (matchImport(\"on\", callee.name)) {\n            // on accepts a signal or an array of signals as its first argument,\n            // and a tracking function as its second\n            if (arg0) {\n              if (arg0.type === \"ArrayExpression\") {\n                arg0.elements.forEach((element) => {\n                  if (element && element?.type !== \"SpreadElement\") {\n                    pushTrackedScope(element, \"function\");\n                  }\n                });\n              } else {\n                pushTrackedScope(arg0, \"function\");\n              }\n            }\n            if (arg1) {\n              // Since dependencies are known, function can be async\n              pushTrackedScope(arg1, \"called-function\");\n            }\n          } else if (matchImport(\"createStore\", callee.name) && arg0?.type === \"ObjectExpression\") {\n            for (const property of arg0.properties) {\n              if (\n                property.type === \"Property\" &&\n                property.kind === \"get\" &&\n                isFunctionNode(property.value)\n              ) {\n                pushTrackedScope(property.value, \"function\");\n              }\n            }\n          } else if (matchImport(\"runWithOwner\", callee.name)) {\n            // runWithOwner(owner, fn) only creates a tracked scope if `owner =\n            // getOwner()` runs in a tracked scope. If owner is a variable,\n            // attempt to detect if it's a tracked scope or not, but if this\n            // can't be done, assume it's a tracked scope.\n            if (arg1) {\n              let isTrackedScope = true;\n              const owner = arg0.type === \"Identifier\" && findVariable(context, arg0);\n              if (owner) {\n                const decl = owner.defs[0];\n                if (\n                  decl &&\n                  decl.node.type === \"VariableDeclarator\" &&\n                  decl.node.init?.type === \"CallExpression\" &&\n                  decl.node.init.callee.type === \"Identifier\" &&\n                  matchImport(\"getOwner\", decl.node.init.callee.name)\n                ) {\n                  // Check if the function in which getOwner() is called is a tracked scope. If the scopeStack\n                  // has moved on from that scope already, assume it's tracked, since that's less intrusive.\n                  const ownerFunction = findParent(decl.node, isProgramOrFunctionNode);\n                  const scopeStackIndex = scopeStack.findIndex(\n                    ({ node }) => ownerFunction === node\n                  );\n                  if (\n                    (scopeStackIndex >= 1 &&\n                      !scopeStack[scopeStackIndex - 1].trackedScopes.some(\n                        (trackedScope) =>\n                          trackedScope.expect === \"function\" && trackedScope.node === ownerFunction\n                      )) ||\n                    scopeStackIndex === 0\n                  ) {\n                    isTrackedScope = false;\n                  }\n                }\n              }\n              if (isTrackedScope) {\n                pushTrackedScope(arg1, \"function\");\n              }\n            }\n          } else if (\n            /^(?:use|create)[A-Z]/.test(callee.name) ||\n            options.customReactiveFunctions.includes(callee.name)\n          ) {\n            // Custom hooks parameters may or may not be tracking scopes, no way to know.\n            // Assume all identifier/function arguments are tracked scopes, and use \"called-function\"\n            // to allow async handlers (permissive). Assume non-resolvable args are reactive expressions.\n            for (const arg of node.arguments) {\n              permissivelyTrackNode(arg);\n            }\n          }\n        } else if (node.callee.type === \"MemberExpression\") {\n          const { property } = node.callee;\n          if (\n            property.type === \"Identifier\" &&\n            property.name === \"addEventListener\" &&\n            node.arguments.length >= 2\n          ) {\n            // Like `on*` event handlers, mark all `addEventListener` listeners as called functions.\n            pushTrackedScope(node.arguments[1], \"called-function\");\n          } else if (\n            property.type === \"Identifier\" &&\n            (/^(?:use|create)[A-Z]/.test(property.name) ||\n              options.customReactiveFunctions.includes(property.name))\n          ) {\n            // Handle custom hook parameters for property access custom hooks\n            for (const arg of node.arguments) {\n              permissivelyTrackNode(arg);\n            }\n          }\n        }\n      } else if (node.type === \"VariableDeclarator\") {\n        // Solid 1.3 createReactive (renamed createReaction?) returns a track\n        // function, a tracked scope expecting a reactive function. All of the\n        // track function's references where it's called push a tracked scope.\n        if (node.init?.type === \"CallExpression\" && node.init.callee.type === \"Identifier\") {\n          if (matchImport([\"createReactive\", \"createReaction\"], node.init.callee.name)) {\n            const track = getReturnedVar(node.id, context);\n            if (track) {\n              for (const reference of track.references) {\n                if (\n                  !reference.init &&\n                  reference.isReadOnly() &&\n                  reference.identifier.parent?.type === \"CallExpression\" &&\n                  reference.identifier.parent.callee === reference.identifier\n                ) {\n                  const arg0 = reference.identifier.parent.arguments[0];\n                  if (arg0) {\n                    pushTrackedScope(arg0, \"function\");\n                  }\n                }\n              }\n            }\n            if (isFunctionNode(node.init.arguments[0])) {\n              pushTrackedScope(node.init.arguments[0], \"called-function\");\n            }\n          }\n        }\n      } else if (node.type === \"AssignmentExpression\") {\n        if (\n          node.left.type === \"MemberExpression\" &&\n          node.left.property.type === \"Identifier\" &&\n          isFunctionNode(node.right) &&\n          /^on[a-z]+$/.test(node.left.property.name)\n        ) {\n          // To allow (questionable) code like the following example:\n          //     ref.oninput = () = {\n          //       if (!errors[ref.name]) return;\n          //       ...\n          //     }\n          // where event handlers are manually attached to refs, detect these\n          // scenarios and mark the right hand sides as tracked scopes expecting\n          // functions.\n          pushTrackedScope(node.right, \"called-function\");\n        }\n      } else if (node.type === \"TaggedTemplateExpression\") {\n        for (const expression of node.quasi.expressions) {\n          if (isFunctionNode(expression)) {\n            // ex. css`color: ${props => props.color}`. Use \"called-function\" to allow async handlers (permissive)\n            pushTrackedScope(expression, \"called-function\");\n\n            // exception case: add a reactive variable within checkForTrackedScopes when a param is props\n            for (const param of expression.params) {\n              if (param.type === \"Identifier\" && isPropsByName(param.name)) {\n                const variable = findVariable(context, param);\n                if (variable) scopeStack.pushProps(variable, currentScope().node);\n              }\n            }\n          }\n        }\n      }\n    };\n\n    return {\n      ImportDeclaration: handleImportDeclaration,\n      JSXExpressionContainer(node: T.JSXExpressionContainer) {\n        checkForTrackedScopes(node);\n      },\n      JSXSpreadAttribute(node: T.JSXSpreadAttribute) {\n        checkForTrackedScopes(node);\n      },\n      CallExpression(node: T.CallExpression) {\n        checkForTrackedScopes(node);\n        checkForSyncCallbacks(node);\n\n        // ensure calls to reactive primitives use the results.\n        const parent = node.parent && ignoreTransparentWrappers(node.parent, true);\n        if (parent?.type !== \"AssignmentExpression\" && parent?.type !== \"VariableDeclarator\") {\n          checkForReactiveAssignment(null, node);\n        }\n      },\n      NewExpression(node: T.NewExpression) {\n        checkForTrackedScopes(node);\n      },\n      VariableDeclarator(node: T.VariableDeclarator) {\n        if (node.init) {\n          checkForReactiveAssignment(node.id, node.init);\n          checkForTrackedScopes(node);\n        }\n      },\n      AssignmentExpression(node: T.AssignmentExpression) {\n        if (node.left.type !== \"MemberExpression\") {\n          checkForReactiveAssignment(node.left, node.right);\n        }\n        checkForTrackedScopes(node);\n      },\n      TaggedTemplateExpression(node: T.TaggedTemplateExpression) {\n        checkForTrackedScopes(node);\n      },\n      \"JSXElement > JSXExpressionContainer > :function\"(node: T.Node) {\n        if (\n          isFunctionNode(node) &&\n          node.parent?.type === \"JSXExpressionContainer\" &&\n          node.parent.parent?.type === \"JSXElement\"\n        ) {\n          const element = node.parent.parent;\n\n          if (element.openingElement.name.type === \"JSXIdentifier\") {\n            const tagName = element.openingElement.name.name;\n            if (\n              matchImport(\"For\", tagName) &&\n              node.params.length === 2 &&\n              node.params[1].type === \"Identifier\"\n            ) {\n              // Mark `index` in `<For>{(item, index) => <div /></For>` as a signal\n              const index = findVariable(context, node.params[1]);\n              if (index) {\n                scopeStack.pushSignal(index, currentScope().node);\n              }\n            } else if (\n              matchImport(\"Index\", tagName) &&\n              node.params.length >= 1 &&\n              node.params[0].type === \"Identifier\"\n            ) {\n              // Mark `item` in `<Index>{(item, index) => <div />}</Index>` as a signal\n              const item = findVariable(context, node.params[0]);\n              if (item) {\n                scopeStack.pushSignal(item, currentScope().node);\n              }\n            }\n          }\n        }\n      },\n\n      /* Function enter/exit */\n      FunctionExpression: onFunctionEnter,\n      ArrowFunctionExpression: onFunctionEnter,\n      FunctionDeclaration: onFunctionEnter,\n      Program: onFunctionEnter,\n      \"FunctionExpression:exit\": onFunctionExit,\n      \"ArrowFunctionExpression:exit\": onFunctionExit,\n      \"FunctionDeclaration:exit\": onFunctionExit,\n      \"Program:exit\": onFunctionExit,\n\n      /* Detect JSX for adding props */\n      JSXElement() {\n        if (scopeStack.length) {\n          currentScope().hasJSX = true;\n        }\n      },\n      JSXFragment() {\n        if (scopeStack.length) {\n          currentScope().hasJSX = true;\n        }\n      },\n    };\n  },\n});\n","/**\n * FIXME: remove this comments and import when below issue is fixed.\n * This import is necessary for type generation due to a bug in the TypeScript compiler.\n * See: https://github.com/microsoft/TypeScript/issues/42873\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { TSESLint } from \"@typescript-eslint/utils\";\n\nimport { TSESTree as T, ESLintUtils } from \"@typescript-eslint/utils\";\nimport { isDOMElementName } from \"../utils\";\nimport { getSourceCode } from \"../compat\";\n\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\n\nfunction isComponent(node: T.JSXOpeningElement) {\n  return (\n    (node.name.type === \"JSXIdentifier\" && !isDOMElementName(node.name.name)) ||\n    node.name.type === \"JSXMemberExpression\"\n  );\n}\n\nconst voidDOMElementRegex =\n  /^(?:area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/;\nfunction isVoidDOMElementName(name: string) {\n  return voidDOMElementRegex.test(name);\n}\n\nfunction childrenIsEmpty(node: T.JSXOpeningElement) {\n  return (node.parent as T.JSXElement).children.length === 0;\n}\n\nfunction childrenIsMultilineSpaces(node: T.JSXOpeningElement) {\n  const childrens = (node.parent as T.JSXElement).children;\n\n  return (\n    childrens.length === 1 &&\n    childrens[0].type === \"JSXText\" &&\n    childrens[0].value.indexOf(\"\\n\") !== -1 &&\n    childrens[0].value.replace(/(?!\\xA0)\\s/g, \"\") === \"\"\n  );\n}\n\ntype MessageIds = \"selfClose\" | \"dontSelfClose\";\ntype Options = [{ component?: \"all\" | \"none\"; html?: \"all\" | \"void\" | \"none\" }?];\n\n/**\n * This rule is adapted from eslint-plugin-react's self-closing-comp rule under the MIT license,\n * with some enhancements. Thank you for your work!\n */\nexport default createRule<Options, MessageIds>({\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"Disallow extra closing tags for components without children.\",\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/self-closing-comp.md\",\n    },\n    fixable: \"code\",\n    schema: [\n      {\n        type: \"object\",\n        properties: {\n          component: {\n            type: \"string\",\n            description: \"which Solid components should be self-closing when possible\",\n            enum: [\"all\", \"none\"],\n            default: \"all\",\n          },\n          html: {\n            type: \"string\",\n            description: \"which native elements should be self-closing when possible\",\n            enum: [\"all\", \"void\", \"none\"],\n            default: \"all\",\n          },\n        },\n        additionalProperties: false,\n      },\n    ],\n    messages: {\n      selfClose: \"Empty components are self-closing.\",\n      dontSelfClose: \"This element should not be self-closing.\",\n    },\n  },\n  defaultOptions: [],\n  create(context) {\n    function shouldBeSelfClosedWhenPossible(node: T.JSXOpeningElement): boolean {\n      if (isComponent(node)) {\n        const whichComponents = context.options[0]?.component ?? \"all\";\n        return whichComponents === \"all\";\n      } else if (node.name.type === \"JSXIdentifier\" && isDOMElementName(node.name.name)) {\n        const whichComponents = context.options[0]?.html ?? \"all\";\n        switch (whichComponents) {\n          case \"all\":\n            return true;\n          case \"void\":\n            return isVoidDOMElementName(node.name.name);\n          case \"none\":\n            return false;\n        }\n      }\n      return true; // shouldn't encounter\n    }\n\n    return {\n      JSXOpeningElement(node) {\n        const canSelfClose = childrenIsEmpty(node) || childrenIsMultilineSpaces(node);\n        if (canSelfClose) {\n          const shouldSelfClose = shouldBeSelfClosedWhenPossible(node);\n          if (shouldSelfClose && !node.selfClosing) {\n            context.report({\n              node,\n              messageId: \"selfClose\",\n              fix(fixer) {\n                // Represents the last character of the JSXOpeningElement, the '>' character\n                const openingElementEnding = node.range[1] - 1;\n                // Represents the last character of the JSXClosingElement, the '>' character\n                const closingElementEnding = (node.parent as T.JSXElement).closingElement!.range[1];\n\n                // Replace />.*<\\/.*>/ with '/>'\n                const range = [openingElementEnding, closingElementEnding] as const;\n                return fixer.replaceTextRange(range, \" />\");\n              },\n            });\n          } else if (!shouldSelfClose && node.selfClosing) {\n            context.report({\n              node,\n              messageId: \"dontSelfClose\",\n              fix(fixer) {\n                const sourceCode = getSourceCode(context);\n                const tagName = sourceCode.getText(node.name);\n                // Represents the last character of the JSXOpeningElement, the '>' character\n                const selfCloseEnding = node.range[1];\n                // Replace ' />' or '/>' with '></${tagName}>'\n                const lastTokens = sourceCode.getLastTokens(node, { count: 3 }); // JSXIdentifier, '/', '>'\n                const isSpaceBeforeSelfClose = sourceCode.isSpaceBetween?.(\n                  lastTokens[0],\n                  lastTokens[1]\n                );\n                const range = [\n                  isSpaceBeforeSelfClose ? selfCloseEnding - 3 : selfCloseEnding - 2,\n                  selfCloseEnding,\n                ] as const;\n                return fixer.replaceTextRange(range, `></${tagName}>`);\n              },\n            });\n          }\n        }\n      },\n    };\n  },\n});\n","/**\n * FIXME: remove this comments and import when below issue is fixed.\n * This import is necessary for type generation due to a bug in the TypeScript compiler.\n * See: https://github.com/microsoft/TypeScript/issues/42873\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { TSESLint } from \"@typescript-eslint/utils\";\n\nimport { TSESTree as T, ESLintUtils, ASTUtils } from \"@typescript-eslint/utils\";\nimport kebabCase from \"kebab-case\";\nimport { all as allCssProperties } from \"known-css-properties\";\nimport parse from \"style-to-object\";\nimport { jsxPropName } from \"../utils\";\nimport { getScope } from \"../compat\";\n\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\nconst { getPropertyName, getStaticValue } = ASTUtils;\n\nconst lengthPercentageRegex = /\\b(?:width|height|margin|padding|border-width|font-size)\\b/i;\n\ntype MessageIds = \"kebabStyleProp\" | \"invalidStyleProp\" | \"numericStyleValue\" | \"stringStyle\";\ntype Options = [{ styleProps?: Array<string>; allowString?: boolean }?];\n\nexport default createRule<Options, MessageIds>({\n  meta: {\n    type: \"problem\",\n    docs: {\n      description:\n        \"Require CSS properties in the `style` prop to be valid and kebab-cased (ex. 'font-size'), not camel-cased (ex. 'fontSize') like in React, \" +\n        \"and that property values with dimensions are strings, not numbers with implicit 'px' units.\",\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/style-prop.md\",\n    },\n    fixable: \"code\",\n    schema: [\n      {\n        type: \"object\",\n        properties: {\n          styleProps: {\n            description: \"an array of prop names to treat as a CSS style object\",\n            default: [\"style\"],\n            type: \"array\",\n            items: {\n              type: \"string\",\n            },\n            minItems: 1,\n            uniqueItems: true,\n          },\n          allowString: {\n            description:\n              \"if allowString is set to true, this rule will not convert a style string literal into a style object (not recommended for performance)\",\n            type: \"boolean\",\n            default: false,\n          },\n        },\n        additionalProperties: false,\n      },\n    ],\n    messages: {\n      kebabStyleProp: \"Use {{ kebabName }} instead of {{ name }}.\",\n      invalidStyleProp: \"{{ name }} is not a valid CSS property.\",\n      numericStyleValue:\n        'This CSS property value should be a string with a unit; Solid does not automatically append a \"px\" unit.',\n      stringStyle: \"Use an object for the style prop instead of a string.\",\n    },\n  },\n  defaultOptions: [],\n  create(context) {\n    const allCssPropertiesSet: Set<string> = new Set(allCssProperties);\n    const allowString = Boolean(context.options[0]?.allowString);\n    const styleProps = context.options[0]?.styleProps || [\"style\"];\n\n    return {\n      JSXAttribute(node) {\n        if (styleProps.indexOf(jsxPropName(node)) === -1) {\n          return;\n        }\n        const style =\n          node.value?.type === \"JSXExpressionContainer\" ? node.value.expression : node.value;\n\n        if (!style) {\n          return;\n        } else if (style.type === \"Literal\" && typeof style.value === \"string\" && !allowString) {\n          // Convert style=\"font-size: 10px\" to style={{ \"font-size\": \"10px\" }}\n          let objectStyles: Record<string, string> | undefined;\n          try {\n            objectStyles = parse(style.value) ?? undefined;\n          } catch {\n            // no-op\n          }\n\n          context.report({\n            node: style,\n            messageId: \"stringStyle\",\n            // replace full prop value, wrap in JSXExpressionContainer, more fixes may be applied below\n            fix:\n              objectStyles &&\n              ((fixer) => fixer.replaceText(node.value!, `{${JSON.stringify(objectStyles)}}`)),\n          });\n        } else if (style.type === \"TemplateLiteral\" && !allowString) {\n          context.report({\n            node: style,\n            messageId: \"stringStyle\",\n          });\n        } else if (style.type === \"ObjectExpression\") {\n          const properties = style.properties.filter(\n            (prop) => prop.type === \"Property\"\n          ) as Array<T.Property>;\n          properties.forEach((prop) => {\n            const name: string | null = getPropertyName(prop, getScope(context, prop));\n            if (name && !name.startsWith(\"--\") && !allCssPropertiesSet.has(name)) {\n              const kebabName: string = kebabCase(name);\n              if (allCssPropertiesSet.has(kebabName)) {\n                // if it's not valid simply because it's camelCased instead of kebab-cased, provide a fix\n                context.report({\n                  node: prop.key,\n                  messageId: \"kebabStyleProp\",\n                  data: { name, kebabName },\n                  fix: (fixer) => fixer.replaceText(prop.key, `\"${kebabName}\"`), // wrap kebab name in quotes to be a valid object key\n                });\n              } else {\n                context.report({\n                  node: prop.key,\n                  messageId: \"invalidStyleProp\",\n                  data: { name },\n                });\n              }\n            } else if (!name || (!name.startsWith(\"--\") && lengthPercentageRegex.test(name))) {\n              // catches numeric values (ex. { \"font-size\": 12 }) for common <length-percentage> peroperties\n              // and suggests quoting or appending 'px'\n              const value: unknown = getStaticValue(prop.value)?.value;\n              if (typeof value === \"number\" && value !== 0) {\n                context.report({ node: prop.value, messageId: \"numericStyleValue\" });\n              }\n            }\n          });\n        }\n      },\n    };\n  },\n});\n","/**\n * FIXME: remove this comments and import when below issue is fixed.\n * This import is necessary for type generation due to a bug in the TypeScript compiler.\n * See: https://github.com/microsoft/TypeScript/issues/42873\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { TSESLint } from \"@typescript-eslint/utils\";\n\nimport { TSESTree as T, ESLintUtils } from \"@typescript-eslint/utils\";\nimport { isDOMElementName, trace } from \"../utils\";\n\nconst createRule = ESLintUtils.RuleCreator.withoutDocs;\n\nexport default createRule({\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow usage of type-unsafe event handlers.\",\n      url: \"https://github.com/solidjs-community/eslint-plugin-solid/blob/main/packages/eslint-plugin-solid/docs/no-array-handlers.md\",\n    },\n    schema: [],\n    messages: {\n      noArrayHandlers: \"Passing an array as an event handler is potentially type-unsafe.\",\n    },\n  },\n  defaultOptions: [],\n  create(context) {\n    return {\n      JSXAttribute(node) {\n        const openingElement = node.parent as T.JSXOpeningElement;\n        if (\n          openingElement.name.type !== \"JSXIdentifier\" ||\n          !isDOMElementName(openingElement.name.name)\n        ) {\n          return; // bail if this is not a DOM/SVG element or web component\n        }\n\n        const isNamespacedHandler =\n          node.name.type === \"JSXNamespacedName\" && node.name.namespace.name === \"on\";\n        const isNormalEventHandler =\n          node.name.type === \"JSXIdentifier\" && /^on[a-zA-Z]/.test(node.name.name);\n\n        if (\n          (isNamespacedHandler || isNormalEventHandler) &&\n          node.value?.type === \"JSXExpressionContainer\" &&\n          trace(node.value.expression, context).type === \"ArrayExpression\"\n        ) {\n          // Warn if passed an array\n          context.report({\n            node,\n            messageId: \"noArrayHandlers\",\n          });\n        }\n      },\n    };\n  },\n});\n","/**\n * FIXME: remove this comments and import when below issue is fixed.\n * This import is necessary for type generation due to a bug in the TypeScript compiler.\n * See: https://github.com/microsoft/TypeScript/issues/42873\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { TSESLint } from \"@typescript-eslint/utils\";\n\nimport componentsReturnOnce from \"./rules/components-return-once\";\nimport eventHandlers from \"./rules/event-handlers\";\nimport imports from \"./rules/imports\";\nimport jsxNoDuplicateProps from \"./rules/jsx-no-duplicate-props\";\nimport jsxNoScriptUrl from \"./rules/jsx-no-script-url\";\nimport jsxNoUndef from \"./rules/jsx-no-undef\";\nimport jsxUsesVars from \"./rules/jsx-uses-vars\";\nimport noDestructure from \"./rules/no-destructure\";\nimport noInnerHTML from \"./rules/no-innerhtml\";\nimport noProxyApis from \"./rules/no-proxy-apis\";\nimport noReactDeps from \"./rules/no-react-deps\";\nimport noReactSpecificProps from \"./rules/no-react-specific-props\";\nimport noUnknownNamespaces from \"./rules/no-unknown-namespaces\";\nimport preferClasslist from \"./rules/prefer-classlist\";\nimport preferFor from \"./rules/prefer-for\";\nimport preferShow from \"./rules/prefer-show\";\nimport reactivity from \"./rules/reactivity\";\nimport selfClosingComp from \"./rules/self-closing-comp\";\nimport styleProp from \"./rules/style-prop\";\nimport noArrayHandlers from \"./rules/no-array-handlers\";\n// import validateJsxNesting from \"./rules/validate-jsx-nesting\";\n\n// Use require() so that `package.json` doesn't get copied to `dist`\n// eslint-disable-next-line @typescript-eslint/no-require-imports\nconst { name, version } = require(\"../package.json\");\nconst meta = { name, version };\n\nconst allRules = {\n  \"components-return-once\": componentsReturnOnce,\n  \"event-handlers\": eventHandlers,\n  imports,\n  \"jsx-no-duplicate-props\": jsxNoDuplicateProps,\n  \"jsx-no-undef\": jsxNoUndef,\n  \"jsx-no-script-url\": jsxNoScriptUrl,\n  \"jsx-uses-vars\": jsxUsesVars,\n  \"no-destructure\": noDestructure,\n  \"no-innerhtml\": noInnerHTML,\n  \"no-proxy-apis\": noProxyApis,\n  \"no-react-deps\": noReactDeps,\n  \"no-react-specific-props\": noReactSpecificProps,\n  \"no-unknown-namespaces\": noUnknownNamespaces,\n  \"prefer-classlist\": preferClasslist,\n  \"prefer-for\": preferFor,\n  \"prefer-show\": preferShow,\n  reactivity,\n  \"self-closing-comp\": selfClosingComp,\n  \"style-prop\": styleProp,\n  \"no-array-handlers\": noArrayHandlers,\n  // \"validate-jsx-nesting\": validateJsxNesting\n};\n\nexport const plugin = { meta, rules: allRules };\n","import type { TSESLint } from \"@typescript-eslint/utils\";\n\nimport { plugin } from \"../plugin\";\n\nconst recommended = {\n  plugins: {\n    solid: plugin,\n  },\n  languageOptions: {\n    sourceType: \"module\",\n    parserOptions: {\n      ecmaFeatures: {\n        jsx: true,\n      },\n    },\n  },\n  rules: {\n    // identifier usage is important\n    \"solid/jsx-no-duplicate-props\": 2,\n    \"solid/jsx-no-undef\": 2,\n    \"solid/jsx-uses-vars\": 2,\n    \"solid/no-unknown-namespaces\": 2,\n    // security problems\n    \"solid/no-innerhtml\": 2,\n    \"solid/jsx-no-script-url\": 2,\n    // reactivity\n    \"solid/components-return-once\": 1,\n    \"solid/no-destructure\": 2,\n    \"solid/prefer-for\": 2,\n    \"solid/reactivity\": 1,\n    \"solid/event-handlers\": 1,\n    // these rules are mostly style suggestions\n    \"solid/imports\": 1,\n    \"solid/style-prop\": 1,\n    \"solid/no-react-deps\": 1,\n    \"solid/no-react-specific-props\": 1,\n    \"solid/self-closing-comp\": 1,\n    \"solid/no-array-handlers\": 0,\n    // handled by Solid compiler, opt-in style suggestion\n    \"solid/prefer-show\": 0,\n    // only necessary for resource-constrained environments\n    \"solid/no-proxy-apis\": 0,\n    // deprecated\n    \"solid/prefer-classlist\": 0,\n  },\n} satisfies TSESLint.FlatConfig.Config;\n\nexport = recommended;\n"],"mappings":"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","names":["exports","module","import_utils","name","name","node","node","test","consequent","import_utils","createRule","name","import_utils","createRule","node","import_utils","createRule","name","node","import_utils","createRule","getStaticValue","import_utils","createRule","isComponent","import_utils","createRule","import_utils","createRule","info","import_utils","createRule","getStringIfConstant","isHtml","import_utils","createRule","import_utils","createRule","import_utils","createRule","import_utils","createRule","import_utils","createRule","import_utils","createRule","import_utils","createRule","import_utils","createRule","node","import_utils","createRule","name","import_utils","createRule","getPropertyName","getStaticValue","allCssProperties","parse","name","kebabCase","import_utils","createRule"]}